
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

function Ray(Vec3 start, Vec3 direction) {
  self.start = start;
  self.direction = direction;
}

function Ray.set(Vec3 start, Vec3 direction) {
  self.start = start;
  self.direction = direction;
}

function Scalar Ray.distanceToPoint(io Vec3 point) {
  Vec3 v, w;
  Scalar c1, c2;
  Scalar rayT, dist;

  w = point - self.start;
  c1 = w.dot(self.direction);
  c2 = v.dot(self.direction);
  rayT = c1 / c2;

  if (rayT >= 0.0) {
    Vec3 pointOnRay = self.start + (rayT * self.direction);
    return pointOnRay.dist(point);
  }
  else {
    return self.start.dist(point);
  }
}

function Scalar Ray.distanceToLine(io Vec3 lineP0, io Vec3 lineP1) {
  Vec3 rayP1;
  rayP1 = self.start + self.direction;

  var Scalar rayT, lineT, dist;
  dist = distanceFromLineToLine(
    self.start, rayP1,
    lineP0, lineP1,
    rayT, lineT
  );

  if (rayT >= 0.0 && lineT >= 0.0 && lineT <= 1.0) {
    return dist;
  }
  if (rayT >= 0.0 && lineT < 0.0) {
    return distFromPointToLine(lineP0, self.start, rayP1);
  }
  if (rayT >= 0.0 && lineT > 1.0) {
    return distFromPointToLine(lineP1, self.start, rayP1);
  }
  // The line segment is behind the ray
  if (lineT >= 0.0 && lineT < 1.0) {
    return distFromPointToSegment(self.start, lineP0, self.start);
  }
  if (lineT < 0.0) {
    return lineP0.dist(self.start);
  }
  else {
    return lineP1.dist(self.start);
  }
}

function Vec2 Ray.intersectLine(io Vec3 lineP0, io Vec3 lineP1) {
  Vec3 rayP1;
  rayP1 = self.start + self.direction;

  var Scalar rayT, lineT, dist;
  dist = distanceFromLineToLine(
    self.start, rayP1,
    lineP0, lineP1,
    rayT, lineT
  );
  return Vec2(rayT, lineT);
}

function Boolean Ray.intersectTriangle(
  Boolean cull,
  Vec3 v0,
  Vec3 v1,
  Vec3 v2,
  io Vec3 point,
  io Scalar dist,
  io Scalar u,
  io Scalar v
) {
  var Vec3 e1 = v1 - v0;
  var Vec3 e2 = v2 - v0;
  var Vec3 pvec = self.direction.cross(e2);
  var Scalar det = e1.dot(pvec);

  if (cull) {
    if (det < 0.00001) {
      return false;
    }
    var Vec3 tvec = self.start - v0;
    u = tvec.dot(pvec);
    if (u < 0.0 || u > det) {
      return false;
    }
    var Vec3 qvec = tvec.cross(e1);
    v = self.direction.dot(qvec);
    if (v < 0.0 || (u + v) > det) {
      return false;
    }
    var Scalar inv_det = 1.0 / det;
    dist = e2.dot(qvec) * inv_det;
    u *= inv_det;
    v *= inv_det;
  }
  else {
    if (det > - 0.00001 && det < 0.00001) {
      return false;
    }
    var Scalar inv_det = 1.0 / det;
    var Vec3 tvec = self.start - v0;
    u = tvec.dot(pvec) * inv_det;
    if (u < 0.0 || u > 1.0) {
      return false;
    }
    var Vec3 qvec = tvec.cross(e1);
    v = self.direction.dot(qvec) * inv_det;
    if (v < 0.0 || (u + v) > 1.0) {
      return false;
    }
    dist = e2.dot(qvec) * inv_det;
  }
  point = self.start + (self.direction * dist);
  return true;
}

function Boolean intersectBBoxEdge(
  Ray ray,
  Vec3 bboxCenter,
  io Vec3 e1,
  io Vec3 e2
) {
  var Vec2 p = ray.intersectLine(e1, e2);
  if (p.y < 0.0 || p.y > 1.0) {
    return false;
  }
  var Vec3 rayPoint = ray.start + (ray.direction * p.x);
  var Vec3 edgeP = e1.lerp(e2, p.y);
  return ((rayPoint - edgeP).dot(rayPoint - bboxCenter) < 0.0);
}

// Note: This intersection test should be performed in object space,
// removing the need for all the matrix > vector multiplications
function Boolean Ray.intersectBoundingBox(
  Vec3 bboxmin,
  Vec3 bboxmax
) {
  var Vec3 bboxCenter = (bboxmin + bboxmax) * 0.5;

  var Vec3 b1 = Vec3(bboxmin.x, bboxmin.y, bboxmin.z);
  var Vec3 b2 = Vec3(bboxmin.x, bboxmax.y, bboxmin.z);
  var Vec3 b3 = Vec3(bboxmin.x, bboxmax.y, bboxmax.z);
  var Vec3 b4 = Vec3(bboxmin.x, bboxmin.y, bboxmax.z);

  var Vec3 t1 = Vec3(bboxmax.x, bboxmin.y, bboxmin.z);
  var Vec3 t2 = Vec3(bboxmax.x, bboxmax.y, bboxmin.z);
  var Vec3 t3 = Vec3(bboxmax.x, bboxmax.y, bboxmax.z);
  var Vec3 t4 = Vec3(bboxmax.x, bboxmin.y, bboxmax.z);

  return (intersectBBoxEdge(self, bboxCenter, b1, t1)
    || intersectBBoxEdge(self, bboxCenter, b2, t2)
    || intersectBBoxEdge(self, bboxCenter, b3, t3)
    || intersectBBoxEdge(self, bboxCenter, b4, t4)

    || intersectBBoxEdge(self, bboxCenter, b1, b2)
    || intersectBBoxEdge(self, bboxCenter, b2, b3)
    || intersectBBoxEdge(self, bboxCenter, b3, b4)
    || intersectBBoxEdge(self, bboxCenter, b4, b1)

    || intersectBBoxEdge(self, bboxCenter, t1, t2)
    || intersectBBoxEdge(self, bboxCenter, t2, t3)
    || intersectBBoxEdge(self, bboxCenter, t3, t4)
  || intersectBBoxEdge(self, bboxCenter, t4, t1));
}
