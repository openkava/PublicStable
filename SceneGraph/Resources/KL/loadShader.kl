
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

function Integer fglCreateAndCompileShader(String shaderName, Integer type, String src) {
  var Integer shaderID = glCreateShader(type);
  if (shaderID == 0) {
    report(shaderName + ' : glCreateShader failed');
    return 0;
  }

  // Load and compile the shader source
  var Integer notused;
  glShaderSource(shaderID, 1, src, notused);
  glCompileShader(shaderID);

  // Check the compile status
  var Integer compiled;
  glGetShaderiv(shaderID, GL_COMPILE_STATUS, compiled);

  if (!compiled)
    report(shaderName + ' : Shader compilation failed:');

  var Integer infoLen = 0;
  glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, infoLen);
  if (infoLen > 0) {
    if (compiled) {
      report(shaderName + ' : Shader compilation succeeded with warnings:');
    }
    var String infoLog;
    glGetShaderInfoLog(shaderID, infoLen, notused, infoLog);

    report(infoLog);
  }
  else if (!compiled) {
    report('<Unknown reason>');
  }

  if (!compiled) {
    glDeleteShader(shaderID);
    return 0;
  }

  return shaderID;
}

function Integer fglCreateProgramFromShaders(
  String shaderName,
  ShaderSource shaders[],
  ShaderProgramParam programParams[]
) {
  if (shaders.size() == 0) {
    report(shaderName + ' : No shaders given to build a program from.');
    return 0;
  }

  var Integer shaderIDs[];
  for (var Size i = 0; i < shaders.size(); i++) {
    var Integer shaderID = fglCreateAndCompileShader(shaderName, shaders[i].type, shaders[i].code);
    if (shaderID == 0)
      break;
    shaderIDs.push(shaderID);
  }

  var Integer programID = 0;
  if (shaderIDs.size() == shaders.size()) {
    programID = glCreateProgram();
    if (programID) {
      for (var Size i = 0; i < shaderIDs.size(); i++) {
        glAttachShader(programID, shaderIDs[i]);
      }
      // The program parameters need to be added before linking
      for (var Size i = 0; i < programParams.size(); i++) {
        glProgramParameteriEXT(programID, programParams[i].id, programParams[i].value);
      }

      glLinkProgram(programID);

      var Integer linked = 0;
      glGetProgramiv(programID, GL_LINK_STATUS, linked);
      if (!linked) {
        report(shaderName + ' : Program linking failed:');
      }

      var Integer infoLen = 0;
      glGetProgramiv(programID, GL_INFO_LOG_LENGTH, infoLen);
      if (infoLen > 0) {
        if (linked) {
          report(shaderName + ' : Program linking succeeded, with warnings:');
        }
        var Integer notused;
        var String infoLog;
        glGetProgramInfoLog(programID, infoLen, notused, infoLog);
        report(infoLog);
      }
      else if (!linked) {
        report('<Unknown reason>');
      }

      if (!linked) {
        glDeleteProgram(programID);
        programID = 0;
      }
    }
  }
  for (var Size i = 0; i < shaderIDs.size(); i++) {
    glDeleteShader(shaderIDs[i]);
  }
  return programID;
}

function String getRTTypeFromOGLType(in Integer oglType) {
  if (oglType == GL_FLOAT)
    return 'Scalar';
  else if (oglType == GL_FLOAT_VEC2)
    return 'Vec2';
  else if (oglType == GL_FLOAT_VEC3)
    return 'Vec3';
  else if (oglType == GL_FLOAT_VEC4)
    return 'Color';
  else if (oglType == GL_INT)
    return 'Integer';
  else if (oglType == GL_BOOL)
    return 'Boolean';
  else if (oglType == GL_FLOAT_MAT3)
    return 'Mat33';
  else if (oglType == GL_FLOAT_MAT4)
    return 'Mat44';

  return '';
}

operator validateShaderBindings(
  io String shaderName,
  io Integer program,
  io ShaderValue uniformValues[],
  io ShaderValue attributeValues[],
) {
  var String name, typeName;
  var Integer i, j, size, type;

  for (i = 0; i < uniformValues.size(); i++) {
    uniformValues[i].location = glGetUniformLocation(program, uniformValues[i].name);
    if (uniformValues[i].location == - 1) {
      report('ERROR: ' + shaderName + ': Attribute does not exist in the shader code: ' + uniformValues[i].name);
    }
  }

  for (i = 0; i < attributeValues.size(); i++) {
    attributeValues[i].location = glGetAttribLocation(program, attributeValues[i].name);
    if (attributeValues[i].location == - 1) {
      report('ERROR: ' + shaderName + ': Attribute does not exist in the shader code: ' + attributeValues[i].name);
    }
  }

  var Integer nbUniforms;
  glGetProgramiv(program, GL_ACTIVE_UNIFORMS, nbUniforms);
  for (i = 0; i < nbUniforms; i++) {
    glGetActiveUniform(program, i, size, type, name);
    //  report( "P: " + i + " - " + size + " - " + type + " - " + name );

    Boolean found = false;
    for (j = 0; j < uniformValues.size(); j++) {
      if (name == uniformValues[j].name) {
        found = true;
        break;
      }
    }
    if (!found) {
      report('WARNING: ' + shaderName + ': Uniform not bound:' + name);
    }
  }

  var Integer nbAttribs;
  glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, nbAttribs);
  for (i = 0; i < nbAttribs; i++) {
    glGetActiveAttrib(program, i, size, type, name);
    //  report( "A: " + i + " - " + size + " - " + type + " - " + name );

    Boolean found = false;
    for (j = 0; j < attributeValues.size(); j++) {
      if (name == attributeValues[j].name) {
        found = true;
        break;
      }
    }
    if (!found) {
      report('WARNING: ' + shaderName + ': Attribute not bound:' + name);
    }
  }
}

operator loadShader(
  io String shaderName,
  io ShaderSource shaders[],
  io ShaderValue uniformValues[],
  io ShaderValue attributeValues[],
  io ShaderProgramParam programParams[],
  io Integer program
) {
  if (!program) {
    program = fglCreateProgramFromShaders(shaderName, shaders, programParams);
    if (program) {
      validateShaderBindings(shaderName, program, uniformValues, attributeValues);
    }
  }
}

operator useProgram(io Integer program) {
  glUseProgram(program);
}