<?xml version="1.0" encoding="UTF-8"?>
<shader>
	<name>NormalMaterial</name>
	
	<uniforms>
	<uniform name="u_materialColor" constant="color"/>
	<uniform name="u_modelViewProjectionMatrix" constant="modelViewProjectionMatrix"  owner="instance"/>
	<uniform name="u_projectionMatrix" constant="projectionMatrix" owner="instance"/>
	<uniform name="u_projectionMatrixInv" constant="projectionMatrixInv" owner="instance"/>
	<uniform name="u_normalMatrix" constant="normalMatrix" owner="instance"/>
	</uniforms>
	
	<attributes>
	<attribute name="a_position" binding="positions"/>
	<attribute name="a_normal" binding="normals"/>
	</attributes>
	
	<programParams>
		<attribute name="GL_GEOMETRY_INPUT_TYPE_EXT" value="GL_TRIANGLES"/>
		<attribute name="GL_GEOMETRY_OUTPUT_TYPE_EXT" value="GL_LINE_STRIP"/>
		<attribute name="GL_GEOMETRY_VERTICES_OUT_EXT" value="2"/>
	</programParams>
	
	<vertexshader>
		<source>
			uniform vec4 u_lightPosition;
			uniform mat4 u_modelViewProjectionMatrix;
			uniform mat3 u_normalMatrix;
			
			attribute vec4 a_position;
			attribute vec3 a_normal;
			
			varying vec3 normal;
			varying vec3 lightDir;
			varying vec3 viewDir;
			
			void main(){
				normal = u_normalMatrix * a_normal;
				gl_Position = u_modelViewProjectionMatrix * a_position;
			}
		</source>
	</vertexshader>
	
	<geometryshader>
		<source>
			#version 120
			#extension GL_EXT_geometry_shader4 : enable
			
			uniform mat4 u_projectionMatrix;
			uniform mat4 u_projectionMatrixInv;

			// Geometry shader takes the varying from the vertex
			// shader as an array equal to the number of components
			// being passed to the geometry shader.
			varying in vec3 normal[];
			
			void main(){
				// Add the normal, which is a vector in view-model space, to the position, which is a point in 
				// projection-view-model space, by transforming the point from projection space, adding the
				// normal, and transforming the resulting offset point back to projection space.
				vec4 V0, V1;
				V0 = gl_PositionIn[0];
				V1 = u_projectionMatrix * ( u_projectionMatrixInv * V0 + vec4( normal[0], 0.0 ) );
				
				gl_Position = V0;
				EmitVertex();
				gl_Position = V1;
				EmitVertex();
				EndPrimitive();
			}
		</source>
	</geometryshader>
	
	<fragmentshader>
		<source>
			uniform vec4 u_materialColor;
			
			void main(){
				gl_FragColor = u_materialColor;
			}
		</source>
	</fragmentshader>
</shader>
