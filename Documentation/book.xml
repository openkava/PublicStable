<?xml version='1.0' encoding='UTF-8'?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:db="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Fabric Engine SceneGraph Documentation</title>
    <copyright>
      <year>2012</year>
      <holder>Fabric Engine Inc.</holder>
    </copyright>
    <author>
      <personname>
        <firstname>Helge</firstname>
        <surname>Mathee</surname>
      </personname>
      <affiliation>
        <orgname>Fabric Engine Inc.</orgname>
        <address>
          <email>helge.mathee@fabric-engine.com</email>
        </address>
      </affiliation>
    </author>
  </info>
  <section>
    <title>Introduction</title>
    <section>
      <title>What's Fabric Engine's SceneGraph?</title>
      <para>The <emphasis role="bold">SceneGraph</emphasis> is a wrapper for its counterpart, the
        Fabric Engine Core. Fabric Engine's core is a very low level system, providing the core
        objects such as a <emphasis role="bold">Dependency Graph Node</emphasis>, <emphasis
          role="bold">Operators</emphasis> and other elements. The <emphasis role="bold"
          >SceneGraph</emphasis> however is an abstraction layer for the core. It provides <emphasis
          role="italic">presets</emphasis> for Dependency Graph Node setups, called the
        SceneGraphNodes. The SceneGraph is purely implemented in JavaScript, and therefore can be
        customized easily for any specialized purpose.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_introduction_01.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The SceneGraph is a factory which is used to create SceneGraphNodes. Each type of
        SceneGraphNode is registered with the SceneGraph on load. The factory function is
        responsible for constructing the underlying dependency graph, and returning an public
        interface. All data associated with the scene graph node is contained in the closure defined
        by the factory function. </para>
      <para>A good understanding of closures and how they work in JavaScript is essential for
        understanding the Fabric SceneGraph.</para>
      <para>The SceneGraph is provided as a series of JavaScript files which implement factory
        functions for a certain usage field, for example the file <emphasis role="italic"
          >Images.js</emphasis> contains several factory functions implementing 2D images, 3D images
        and video SceneGraphNodes.</para>
      <para>SceneGraphNodes encapsulate the core objects necessary to provide a certain
        functionality. The VideoNode, for example, contains the Dependency Graph Nodes to store all
        of the video related data, as well as all of the Operators to read and manipulate the video
        stream. Moreover it provides JavaScript functions to access and manipulate the video. </para>
      <para><emphasis role="bold">Managers</emphasis> are similar to SceneGraphNodes and are used
        mainly to provide utility functionality. One example of a manager is the UndoManager.
        Managers are genrally singletons, in that only on of each type of Manager is constructed. </para>
      <para>The SceneGraph also provides graphical utilities, such as the <emphasis role="bold"
          >Debugger</emphasis>, which provides an graph based representation of the constructed core
        Dependency Graph. Other tools, for example the <emphasis role="bold">Curve
        Editor</emphasis>, provide a graphical Curve editor for keyframe animation curves.</para>
    </section>
    <section>
      <title>Abstraction of the Dependency Graph</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_introduction_02.png" width="75%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The goal of the SceneGraph layer is to present an interface to developers focused on
        SceneGraph construction. The interfaces exposed follow common SceneGraph conventions. </para>
      <para>SceneGraphs can be setup in a few lines of code, and provide a rich array of features,
        from shader management and rendering, to manipulation and animation.</para>
      <para>The SceneGraph is written entirely in JavaScript, and it abstracts the notion of the
        dependency graph away from the user. The JavaScript code assembles a lower level dependency
        graph. </para>
    </section>
    <section>
      <title>Scene Object and SceneGraphNode Construction</title>
      <para>The <emphasis role="bold">scene</emphasis> provides basic services such as time
        management, and and is used to construct SceneGraphNodes.</para>
      <para>
        <programlisting>var scene = FABRIC.SceneGraph.createScene();</programlisting>
      </para>
      <para>The first SceneGraph object to be constructed is usually the scene object. The scene
        object creates a Fabric Engine context, a dependency graph node for containing globals, and
        some event handlers that are used in rendering. It returns a public interface which provides
        methods for constructing SceneGrapNodes. </para>
      <para>All SceneGraphNode types implemented in the SceneGraph are registered by providing their
        type as well as a constructor function. A SceneGraphNode can be constructed iin the
        following way:</para>
      <para>
        <programlisting>var sgNode = scene.constructNode('Image2D', { name: 'myImageNode' } );</programlisting>
      </para>
      <para>The construction options supported by each SceneGraphNode can be found in the <emphasis
          role="bold">SceneGraphNode Reference</emphasis> of this document. </para>
    </section>
    <section>
      <title>Public and Private Interfaces</title>
      <para>Each SceneGraphNode provides a private as well as a public interface. The public
        interface provide the public interface for the node. Outside of constructor functions it's
        only possible to access the public interface, while inside of constructor functions it's
        possible to access both the public and the private interface. This private interface enables
        exposing functions to tother nodes that request access to the private interface. Private
        interfaces expose methods that are used when building the underlying dependency graph. The
        public interface of a node should expose functions which define very high level behavior.
        For example, the sphere primitive exposes a public interface with methods to get and set the
        radius, and the private interface exposes methods to retrieve the core DGNodes that contain
        all the vertices. The public interface is what would be used to populte a graphical user
        interface for a node. Since the options used for the construction of a node can contain
        references to a public interface, you can retrieve the private interface by using this
        call:</para>
      <programlisting>var privateInterface = scene.getPrivateInterface(publicInterface);</programlisting>
      <para>To access the public interface from a private one, you simply need to access the
          <emphasis role="italic">.pub</emphasis> member of the private interface. Managers can also
        access private interfaces, allowing them to perform changes to the private data, for
        example.</para>
      <programlisting language="JavaScript">var sgNode = {
  pub: {
    publicMethod: function () {}
  },
  privateMethod: function () {}
};</programlisting>
    </section>
    <section>
      <title>Custom SceneGraphNodes and Inheritance</title>
      <para>Applications can register their own, custom SceneGraphNodes. This can be useful and
        necessary when extending an existing node or providing a completely new one. In the
        constructor function of the custom node the other nodes can be accessed through their
        private interfaces, allowing access the inner workings of the SceneGraph. Each Scene Graph
        node extends the private or the public interface of its parent node type, enbling
        inheritance through composition. It is also possible to override an existing function on
        each interface by simply setting it to different function inside the custom node's
        constructor. For further details refer to the tutorials sections of this document.</para>
    </section>
    <section>
      <title>The SceneGraph Debugger</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/sg_debugger_01.png" width="100%"/>
        </imageobject>
      </mediaobject>
      <para>The debugger is a useful tool to inspect the dependency graph contructed by the
        SceneGraph. Especially when building custom SceneGraphNodes this can be very helpful. The
        debugger is described in more detail in the section on the Drawing Pipeline Guide in this
        document. You can open the debugger by using executing this code in JavaScript:</para>
      <programlisting language="JavaScript">FABRIC.displayDebugger();</programlisting>
    </section>
  </section>
  <section role="">
    <title>SceneGraph Type System</title>
    <para>Fabric Engine enables you to define your own data structures. All data types in Fabric are
      define dynamically as part of the loading process of your application. To define the structure
      of data, you need to introduce <emphasis role="bold">Types</emphasis>. Types are very similar
      to structs in C++. Core types, such as <emphasis role="bold">Integer</emphasis>, <emphasis
        role="bold">Boolean</emphasis> or <emphasis role="bold">String</emphasis> are defined by the
      core. More complex types, such as the <emphasis role="bold">Vec3</emphasis>, for example, are
      defined by the SceneGraph.</para>
    <section>
      <title>Querying types</title>
      <para>You can access all of the currently registered types, by calling on the <emphasis
          role="bold">RegisteredTypesManager</emphasis>. The manager is only accessible in the scope
        of a SceneGraphNode factory function, but you can access a dictionary of all current types
        by accessing the <emphasis role="bold">RT</emphasis> object:</para>
      <programlisting language="JavaScript">console.log(FABRIC.RT);</programlisting>
      <para>Types are typically implemented in separate JavaScript files. The ones provided by the
        SceneGraph can be found in the RT directory. The SceneGraph uses a <emphasis role="bold"
          >require</emphasis> framework which ensures that all required scripts are load into the
        application. You can find more details about this in the tutorials section of this document,
        covering the creation of a custom SceneGraphNode.</para>
    </section>
    <section>
      <title>JavaScript and KL</title>
      <para>Types can provide extra functionality both in JavaScript as well as Fabric Engine's
        kernel language (<emphasis role="bold">KL</emphasis>). The type below implements an
          <emphasis role="bold">Address</emphasis>, and implements both a JavaScript file as well as
        a KL file providing the additional functions, called the <emphasis role="bold"
          >bindings</emphasis>. The content of the JavaScript file looks like this: (the first array
        parameter is the list of requirements. this could include other types, for example.)</para>
      <programlisting language="JavaScript">FABRIC.define([], function() {

  // Constructor:
  FABRIC.RT.Address = function(options) {
    if(!options) options = {};
    this.street = options.street != undefined ? options.street : '';
    this.number = options.number != undefined ? options.number : 1;
    this.city = options.city != undefined ? options.city : '';
    this.zip = options.zip != undefined ? options.zip : 1000;
    this.country = options.country != undefined ? options.country : '';
  };
  
  // Prototype, providing additional methods
  FABRIC.RT.Address.prototype = {
    getPrintable: function() {
      return this.street + ' ' + this.number + ' in ' + this.zip + ' ' + this.city + ', ' + this.country;
    }
  };
  
  // Append this type to be loaded once the Fabric context exists
  FABRIC.appendOnCreateContextCallback(function(context) {
    context.RegisteredTypesManager.registerType('Address', {
      members: {
        street: 'String', number: 'Integer', city: 'String', zip: 'Integer', country: 'String'
      },
      constructor: FABRIC.RT.Address,
      klBindings: {
        filename: 'Address.kl',
        sourceCode: FABRIC.loadResourceURL('RT/Address.kl')
      }
    });
  });

  return FABRIC.RT.Address;
});</programlisting>
      <para>The KL file mentioned in the appendOnCreateContextCallback above, <emphasis role="bold"
          >RT/Address.kl</emphasis> could look like this:</para>
      <programlisting language="JavaScript">function String Address.getPrintable() {
  return this.street + ' ' + this.number + ' in ' + this.zip + ' ' + this.city + ', ' + this.country;
}</programlisting>
      <para>This will make the <emphasis role="bold">getPrintable</emphasis> method available both
        in JavaScript as well as in KL. As you can see, you can specify any type of data. You can of
        course include custom types as members of other custom types, and therefore build very
        complex structures, which then can be used for computation inside the dependency graph or
        MapReduce.</para>
    </section>
  </section>
  <section>
    <title>Kinematics Guide</title>
    <section>
      <title>Basic Transform</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_kinematics_01.png" width="45%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The SceneGraph's basic transform can represent a global or a hierarchical transform. It
        can be contructed like this:</para>
      <programlisting language="JavaScript">var globalTransform = scene.constructNode('Transform', {
  hierarchical: false
});
var hierarchicalTransform = scene.constructNode('Transform', {
  hierarchical: true,
  parentTransformNode: globalTransform
});</programlisting>
      <para>When contructed in global mode (hierarchical: false), the transform simply constructs
        global matrix based on the localXfo value. When contructed in hierarchical mode, a parent
        Transform node must also be provided. The transform node builds its global Xfo by
        multiplying the parent's global Xfo by its own local Xfo to get a new global Xfo.
        Hierarchies of transforms can be connected together to drive complex hierarchical
        animation.</para>
      <para>When creating the transform node, you can specify the global or the local transform by
        providing a <emphasis role="bold">FABRIC.RT.Xfo</emphasis>:</para>
      <programlisting language="JavaScript">var globalTransform = scene.constructNode('Transform', {
  hierarchical: false,
  globalXfo: new FABRIC.RT.Xfo({
    tr: new FABRIC.RT.Vec3(1.0, 2.0, 3.0)
  })
});</programlisting>
    </section>
    <section>
      <title>Aimed Transform</title>
      <para>For the typical <emphasis role="italic">lookat</emphasis> behaviour of a transform, for
        example used for a camera with an lookat position, or a spot light with a target position,
        the SceneGraph provides a specialized transform node called the <emphasis role="bold"
          >AimTransform</emphasis>. It adds an additional option to the factory function, which
        allows you to specify the target position.</para>
      <programlisting language="JavaScript">var aimTransform = scene.constructNode('AimTransform', {
  globalXfo: new FABRIC.RT.Xfo({
      tr: new FABRIC.RT.Vec3(1.0, 2.0, 3.0)
  }),
  target: new FABRIC.RT.Vec3(10.0, 0.0, 0.0)
});</programlisting>
      <para>The upvector direction used for the AimTransform is always the positive Y axis.</para>
    </section>
  </section>
  <section>
    <title>Animation Guide</title>
    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/sg_animation_01.png" width="60%"/>
        </imageobject>
      </inlinemediaobject></para>
    <para>The animation pipeline in Fabric Engine's SceneGraph is inspired by the animation systems
      commonly found in game engines. The SceneGraphNodes in the animation pipeline are:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">AnimationController</emphasis></para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">TrackAnimationContainer</emphasis></para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">CharacterAnimationContainer</emphasis></para>
      </listitem>
    </itemizedlist>
    <para>The evaluation of the animation is done in KL operators on the target nodes. In the image
      above the animation is driving a transform node, but any member on any kind of node can be
      driven by animation in Fabric Engine's SceneGraph.</para>
    <section>
      <title>The Animation Controller node</title>
      <para>An Animation Controller is responsible for computing a time value from given inputs. The
        Animation Controller takes in a time paramter and uses it to compute a new time value. For
        example, an Animaiton Controller might take in global time and compute a, loop or ping-pong
        time value which is then used to drive an animation evaluation. A single controller can be
        used by many evaluators. The default Animation Controller node is bound to the globals
        SceneGraph node storing the global scene time.</para>
      <programlisting language="JavaScript">var controller = scene.constructNode('AnimationController', {
  timeRange: new FABRIC.RT.Vec2(0.0, 10.0), // ten seconds
  outOfRange: 1 // looping
});</programlisting>
    </section>
    <section>
      <title>The TrackAnimationContainer</title>
      <para>Both the <emphasis role="bold">TrackAnimationContainer</emphasis> as well as the
          <emphasis role="bold">CharacterAnimationContainer</emphasis> inherit from the <emphasis
          role="bold">AnimationContainer</emphasis>. The AnimationContainer SceneGraph node
        represents a container for any kind of animation. The TrackAnimationContainer uses a sliced
        dependency graph node to store many animation tracks in a single node. All tracks on the
        TrackAnimationContainer have to contain the same type of keys, which is why you can't
        construct a TrackAnimationContainer as is, you need to instantiate inherited nodes of it,
        such as the <emphasis role="bold">LinearTrackAnimationContainer</emphasis> containing linear
        keys or <emphasis role="bold">BezierTrackAnimationContainer</emphasis> containing bezier
        keys.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_02.png" width="30%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The TrackAnimationContainer represents a single animation of multiple tracks. The
        benefit of the TrackAnimationContainer is that tracks are stores in slices, and processing
        on the tracks can happen in a multi-threaded fashion.</para>
      <programlisting language="JavaScript">var linearkey = function(time, value){ return new FABRIC.RT.LinearKeyframe(time, value); };

var trackContainer = scene.constructNode('LinearTrackAnimationContainer', {});

trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.x', FABRIC.RT.rgb(1, 0, 0), [
  linearkey(0, 0), linearkey(50, 0), linearkey(75, 50), linearkey(100, 0)
]));
trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.y', FABRIC.RT.rgb(0, 1, 0), [
  linearkey(0, 0), linearkey(50, 10), linearkey(75, 00), linearkey(100, 0)
]));
trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.z', FABRIC.RT.rgb(0, 0, 1), [
  linearkey(0, 0), linearkey(50, 30), linearkey(75, 00), linearkey(100, 30)
]));</programlisting>
      <para>The code above create a small helper function for creating a linear key frame, then the
        track animation container is created. Once the container exists tracks can be pushed to it,
        providing the name of the track, a color for the UI as well as an array of keys for the
        track.</para>
    </section>
    <section>
      <title>The CharacterAnimationContainer</title>
      <para>The <emphasis role="bold">CharacterAnimationContainer</emphasis> on the other hand is
        quite different from the TrackAnimationContainer. It stores a complete animation containing
        several tracks per slice, allowing to store a large number of complete animations on a
        single node. This container can be understood as a library of animations. Each animation is
        stored as a <emphasis role="bold">TrackSet</emphasis>, which is essentially an array of
        tracks as well as a name for the TrackSet.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_03.png" width="70%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The CharacterAnimationContainer is used for the character pipeline, and will be
        discussed in more detail in the characters related section of this document. Essentially
        though, this is how you create a CharacterAnimationContainer:</para>
      <programlisting language="JavaScript">var linearkey = function(time, value){ return new FABRIC.RT.LinearKeyframe(time, value); };

var characterContainer = scene.constructNode('LinearCharacterAnimationContainer', {});

var walking = characterContainer.newTrackSet('walking');
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.x', FABRIC.RT.rgb(1, 0, 0), [
  linearkey(0, 0), linearkey(50, 0), linearkey(75, 50), linearkey(100, 0)
]));
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.y', FABRIC.RT.rgb(0, 1, 0), [
  linearkey(0, 0), linearkey(50, 10), linearkey(75, 00), linearkey(100, 0)
]));
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.z', FABRIC.RT.rgb(0, 0, 1), [
  linearkey(0, 0), linearkey(50, 30), linearkey(75, 00), linearkey(100, 30)
]));

characterContainer.addTrackSet(walking, [0,1,2]);</programlisting>
    </section>
    <section>
      <title>Binding animation to target nodes</title>
      <para>To use the animation on a target node, such as a transform node, for example, you can
        call the <emphasis role="bold">bindNodeMembersToTracks</emphasis> method of the animation
        container. You need to specify the target binding which includes the name of the member on
        the target node as well as the tracks that need to be bound to it. This you can drive
        complex types, as as a <emphasis role="bold">Vec3</emphasis> for example, you can bind
        multiple tracks to the same member. In the case of a Vec3 the first track will go to the x
        component, the second track to the y component and so on.</para>
      <programlisting language="JavaScript">trackContainer.bindNodeMembersToTracks(transform, {
  'globalXfo.tr': [0, 1, 2] // representing the tracks tr.x, tr.y and tr.z
}, controller);</programlisting>
      <para>Binding the animation on the target node will create an operator on the target's
        dependency graph node which evaluates the animation provided in the animation container and
        writes to the target node's member data. The operator also binds in the animation controller
        which was used during the construction of the animation container. If you don't provide a
        controller to the bindNodeMembersToTracks method the generated operator will simply bind to
        the global time. So in the case discussed in the code snippets in the animation guide, the
        resulting graph will look like this:</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_04.png" width="80%"/>
          </imageobject>
        </inlinemediaobject></para>
    </section>
  </section>
  <section>
    <title>Geometry Guide</title>
    <para>The geometry hierarchy in Fabric Engine's SceneGraph follows a classical inheritance
      model. Each node in the hierarchy adds functionality the the constructed SceneGraph node.
      Geometry can be created in several ways:</para>
    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/sg_geometry_01.png" width="75%"/>
        </imageobject>
      </inlinemediaobject></para>
    <para>1. A base geometry type can be constructed, and its geometry data can be populated from
      JavaScript:</para>
    <programlisting language="JavaScript">var geometryNode = scene.pub.constructNode('Triangles');
geometryNode.loadGeometryData({
  positions: [FABRIC.RT.vec3(0, 0, 0), FABRIC.RT.vec3(0, 0, 1.0), FABRIC.RT.vec3(1.0, 0, 0)], 
  indices: [0, 1, 2]
}); </programlisting>
    <para>2. Geometry can be constructed by loading an external resource file, such as an OBJ file,
      for example:</para>
    <programlisting language="JavaScript">scene.importAssetFile('Models/cow.obj',{ splitMaterials: true } );</programlisting>
    <para>3. A primitive can be constructed. The primitive constructor assigns geometry generation
      operators which create all of the vertices and other data such as normals based on options on
      the primitive.</para>
    <programlisting language="JavaScript">var primitiveNode = scene.constructNode('Circle', { radius: 7 });</programlisting>
    <section>
      <title>Anatomy of a Geometry Node</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_02.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>A geometry SceneGraphNode contains several dependency graph nodes. Fabric Engine's
        slicing scheme is used to represent the data, and to allow high performance operations such
        as deformation on the geometry using multi-threading.</para>
      <para>The <emphasis role="bold">Uniforms</emphasis> node stores single values that are
        associated with the geometry, but don't vary per component. Primitives assign uniform values
        that are often exposed from the scene graph node as modifiable parameters. Triangles and
        Lines also store an array of Integers on the Uniforms node called <emphasis role="bold"
          >indexList</emphasis> which defines the connectivity of points for lines and
        triangles.</para>
      <para>The <emphasis role="bold">Attributes</emphasis> node stores all the ‘per-component’
        information. Attributes can easily be added and removed from geometry by simply adding and
        removing members from this node. The Attributes node is sliced, so the number of slices
        matches the number of vertices, for example.</para>
      <para>The <emphasis role="bold">BoundingBox</emphasis> node is generated using the attributes,
        and is used to accelerate interaction with the geometry such as raycasting.</para>
    </section>
    <section>
      <title>Geometry Generation</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_03.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Note: this are will be re-structured slightly once we have support for node
        nesting.</para>
      <para>The purpose of a generator operator is to generate the vertex information that is stored
        in the attributes node, and the indexList (for Triangles and Lines), which is stored in the
        ‘Uniforms’ node. First we calculate the number of vertices in the <emphasis role="bold"
          >setCount</emphasis> operator, and then populate the attributes node in the second
        operator. The second operator also writes the indexList which is stored on the Uniforms
        node.</para>
    </section>
    <section>
      <title>Geometry Services</title>
      <para>A key service that the the Geometry node provides is integration with the rendering
        pipeline. The design of Fabric Engine's SceneGraph is based heavily on OpenGL shading
        language GLSL, and all rendering in the OpenGL viewport is performed via shaders. </para>
      <para>The geometry node constructs an event handler and binds operators to it for loading all
        the various vertex attributes into the GPU and storing the buffer ids. This means that you
        can add a new vertex attributes to a geometry, then use that data in a shader and the
        geometry node will take care of loading the data so it is ready for the shader. This is
        discussed in more detail in the <emphasis role="bold">Drawing Pipeling Guide</emphasis>
        section of this document.</para>
    </section>
    <section>
      <title>Geometry Data Copies</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_04.png" width="60%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Geometry data copies provide a way to split the definition of a rendered geometry into
        multiple sections. A Geometry data copy is used to extend a base geometry, usually by adding
        deformation operators. The base geometry represents the original undeformed geometry, and
        the data copy is used to apply changes. The Geometry data does not contain a complete
        description of gometry, but only the the data that is a modification of the base geometry.
        During rendering, uniforms and attributes are loaded from the base geometry and the data
        copy where any attributes in the data copy verride the attributes in the base
        geometry.</para>
      <para>Since the Attributes node is sliced, deformation can be performed using
        multi-threading.</para>
      <programlisting language="JavaScript">var geometryCopyNode = scene.constructNode('GeometryDataCopy', {baseGeometryNode: geometryNode} );
geometryCopyNode.addVertexAttributeValue('positions', 'Vec3', { genVBO:true, dynamic:true } );</programlisting>
      <para>Note: The <emphasis role="italic">PerPointDeformation.html</emphasis> sample application
        contains an example of this.</para>
    </section>
  </section>
  <section>
    <title>Parsers Guide</title>
    <para>Fabric Engine's SceneGraph comes with several parsers for importing external resource
      files. Since the loading of external data happens asynchronously, you will need to provide
      callback functions to the parsers, which will executed once the content is loaded, parsed and
      ready for use. Parsers are automatically invoked and chosen based on the file extension of the
      resource to load.</para>
    <section>
      <title>The OBJ Parser</title>
      <para>The OBJ file format can store polygonal meshes with UV coordinates as well as basic
        material settings. You can use the OBJ parser like this:</para>
      <programlisting language="JavaScript">scene.importAssetFile('Models/cow.obj', {splitMaterials: false}, function(assetNodes) {
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>The last argument to the <emphasis role="bold">importAssetFile</emphasis> method is the
        callback function to execute once the parsed result is ready for consumption. The OBJ parser
        returns a dictionary of triangle geometry nodes representing all of the geometries which are
        part of the OBJ file. If the <emphasis role="bold">splitMaterials</emphasis> option is set
        to true, the Obj parser will splith the geometries into multiple geometry sets according to
        the material assignments in the file.  Each returned geometry can then be assigned  separate
        materials for rendering.</para>
      <para>Note: The <emphasis role="italic">ModelViewer.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the OBJ parser in
        use.</para>
    </section>
    <section>
      <title>The Collada Parser</title>
      <para>Collada's DAE file format can store complex types of data, including polygonal meshes,
        transform hierarchies, point clouds as well as other complex 3D data structures. The
        SceneGraph's collada parser currently supports:<itemizedlist>
          <listitem>
            <para>Polygonal Meshes including UV coordinates and skinning weights, imported as
              Triangles nodes</para>
          </listitem>
          <listitem>
            <para>Character Hierarchies used for skinning, imported as CharacterRig nodes</para>
          </listitem>
          <listitem>
            <para>FCurve animation on hierarchies, imported as CharacterAnimationContainer
              nodes</para>
          </listitem>
          <listitem>
            <para>Cameras including focal length and aperture settings, imported as Camera
              nodes</para>
          </listitem>
        </itemizedlist></para>
      <para>The Collada parser can be invoked like this:</para>
      <programlisting language="JavaScript">scene.importAssetFile('Models/character.dae', {
    constructRigFromHierarchy: true
}, function(assetNodes) {
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>The last argument of the parser's invocation is a callback function to be called once
        the collada data is parsed and ready for consumption. In the example above we simply log the
        data to the console. For further details on the character related nodes please see the
          <emphasis role="bold">Character Guide</emphasis> section of this document.</para>
      <para>Note: The <emphasis role="italic">CharacterSkeleton.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the Collada parser in
        use.</para>
    </section>
    <section>
      <title>The Alembic Parser</title>
      <para>Alembic ABC file format can store several kinds of data. The SceneGraph's Alembic
        intergration currently supports:<itemizedlist>
          <listitem>
            <para>Polygonal Meshes including UV coordinates and normals, imported as Triangle
              nodes</para>
          </listitem>
          <listitem>
            <para>Curve lists including width and color values, imported as Lines nodes</para>
          </listitem>
          <listitem>
            <para>Cameras with proper focal length and aperture settings, imported as Camera
              nodes</para>
          </listitem>
          <listitem>
            <para>Point clouds including full transform support, color values, imported as Points
              nodes</para>
          </listitem>
        </itemizedlist></para>
      <para>Since Alembic stores animation as discrete samples the parser doesn't load all of the
        data to memory, but rather constructs operators which re-evaluate based on time changes.
        This way animation can be loaded into Fabric Engine and synchronized with the SceneGraph's
        global time or a different AnimationController.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_parsers_01.png" width="80%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The Alembic resource node holds what is called a <emphasis role="bold"
          >AlembicHandle</emphasis> to the original resource file, which is forwarded through the
        dependency graph and used by all of the ABC operators to pull the relevant data out of the
        Alembic file. Per se there is no parsing happening in JavaScript, so once the resource is
        loaded, the <emphasis role="bold">loadSuccess</emphasis> event fires. The sample code below
        shows how to load data from an Alembic resource. For more details on event handling please
        refer to the <emphasis role="bold">Event Guide</emphasis> section of this document.</para>
      <programlisting language="JavaScript">var alembicLoadNode = scene.constructNode('AlembicLoadNode', {
  url: 'Models/cow.abc'
});
alembicLoadNode.addEventListener('loadSuccess', function(){
  var assetNodes = alembicLoadNode.getParsedNodes(); 
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>Note: The <emphasis role="italic">Alembic/Primitives.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the Alembic parser in
        use.</para>
    </section>
  </section>
  <section>
    <title>Characters Guide</title>
    <para>This is do be done for Phil!</para>
  </section>
  <section>
    <title>Images and Video Guide</title>
    <para>The SceneGraph supports reading and using external image resource files as well as
      external video streams. Typically images are never loaded onto dependency graph nodes or
      stored in the main memory, they are rather pushed directly to the GPU. When drawing textures
      there is no need to keep the image in the RAM, however if you want to modify the image using
      the CPU the images has to be stored in the dependency graph. Fabric Engine supports 2D images
      as well as 3D images.</para>
    <section>
      <title>Anatomy of an Image node</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_images_01.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Similar to the Geometry node, an image node is split into two dependency graph nodes.
        The <emphasis role="bold">Uniforms</emphasis> node stores all of the non-per-pixel data,
        such as the width and height of the image. These values are typically exposed to the
        SceneGraph node as getter function. The <emphasis role="bold">Attributes</emphasis> node
        contains the per pixel data, however only if the Attributes dependency node is required at
        all. As mentioned above the per pixel data is normally directly pushed to the GPU.</para>
    </section>
    <section>
      <title>Loading 2D Images</title>
      <para>Currently the SceneGraph supports loading 2d images of the types <emphasis role="bold"
          >JPG</emphasis>, <emphasis role="bold">PNG</emphasis>, <emphasis role="bold"
          >BMP</emphasis>, <emphasis role="bold">TIF</emphasis>, <emphasis role="bold"
          >EXR</emphasis>, and <emphasis role="bold">HDR</emphasis>. The last two are stores as
        floating point images, while the other formats are stored as byte images. 2d images are
        always stored as RGBA, even if the original image data doesn't contain an alpha
        channel.</para>
      <programlisting language="JavaScript">var image2D = scene.constructNode('Image2D', {
  url: 'Resources/tomatoes_960_640.png',
  createDgNodes: false
});</programlisting>
      <para>If you want the image to be loaded into the RAM and accessible in the dependency graph,
        you need to set the <emphasis role="bold">createDgNodes</emphasis> option to true. You can
        then attach operators to the Attributes node to perform per pixel calculations in a
        multi-threaded fashion.</para>
      <para>Note: The <emphasis role="italic">BackgroundTexture.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains a simple example of an image node in
        use.</para>
    </section>
    <section>
      <title>Loading 3D Images</title>
      <para>Currently the SceneGraph only supports loading 3d images of the type <emphasis
          role="bold">NRRD</emphasis>. 3d images are always stored as USHORT with RGBA
        channels.</para>
      <programlisting language="JavaScript">var image3D = scene.constructNode('Image3D', {
  url: 'Resources/threed_texture.nrrd',
  createDgNodes: false
});</programlisting>
      <para>As with 2d iamges, if you want the image to be loaded into the RAM and accessible in the
        dependency graph, you need to set the <emphasis role="bold">createDgNodes</emphasis> option
        to true.</para>
      <para>Note: The <emphasis role="italic">MedicalImaging.html<emphasis role="bold"
          > </emphasis></emphasis>use-case application contains an example of a 3d image node in
        use.</para>
    </section>
    <section>
      <title>Loading Video</title>
      <para>Video nodes are pretty much the same as Image2D nodes, except that they have operators
        attached which pull frames out of the external video file resource. For that, the current
        frame is stored on the Attributes dependency graph node and is constantly pushed to the GPU
        if the time of the video changes. Fabric Engine utilizes the <emphasis role="bold"
          >FFMPEG</emphasis> library to offer support for a wide variety of video formats. Aside
        from other formats, the SceneGraph's video node supports: <emphasis role="bold"
          >AVI</emphasis>, <emphasis role="bold">MOV</emphasis> and <emphasis role="bold"
          >MP4</emphasis>. </para>
      <programlisting language="JavaScript">var videoNode = scene.constructNode('Video', {
  url: 'Resources/bee_960.mov',
  loop: true
});</programlisting>
      <para>Note: The <emphasis role="italic">Video.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains a simple example of a video node in
        use.</para>
    </section>
  </section>
  <section>
    <title>Drawing Pipeline Guide</title>
    <para>Fabric Engine's SceneGraph's drawing pipeline is very flexible and customizable. Drawing
      is performed with as few operations as possible providing high performance rendering.
      Generally is is important to understand that drawing invokes the evaluation of the dependency
      graph.</para>
    <section>
      <title>Predescend and Postdescend</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_01.png" width="70%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The drawing pipline is implemented using eventhandlers. The eventhandler tree for
        drawing listens to the paint event of the canvas resp. the windows. The drawing pipeline
        evaluates in two phases: the <emphasis role="bold">Predescend</emphasis> and <emphasis
          role="bold">Postdescent</emphasis>. Predescend happens when the drawing pipline evaluates
        each event handler from left to right, resp. from the event down to the last eventhandler.
        Postdescend happens once the descend is done, traveling through the event graph back up to
        the event. Operators for drawing can be applied on either the <emphasis role="bold"
          >preDescendBindings</emphasis> or the <emphasis role="bold"
          >postDescendBindings.</emphasis> When each eventhandler evaluates it pulls on the
        connected dependency graph nodes. If the dependency graph node itself has dependencies and
        operators, the execution of the dependencies and operatos will be fired.</para>
    </section>
    <section>
      <title>Windows</title>
      <para>Each window in Fabric defines a dependency graph node and an Event. The node contains
        data about the window such as its width and height, and the event is fired when painting of
        the window is required. The width and height values are driven by the Fabric plugin, and are
        updated when the window is resized.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_02.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The Window Event node is an event that is fired whenever the window needs painting. This
        may occur because the window was resized, revealed, or invalidated in any way. It is also
        possible to manually trigger a redraw from JavaScript. Redrawing of the window during
        animation is effected by modifying graph variables such as time, and then manually
        triggering a redraw. The JavaScript mechanism to fire a redraw manually is accessible
        through the <emphasis role="bold">Viewport</emphasis> node.</para>
      <programlisting language="JavaScript">var viewport = scene.constructNode('Viewport', {
  windowElement: document.getElementById('FabricContainer') // provide the HTML element for the viewport
});
// fire a redraw manually
viewport.redraw();</programlisting>
      <para>By attaching event handlers to the Window Paint Event node, we can coordinate the
        drawing of the window using OpenGL. The OpenGL context is set up and bound prior to the
        paint event being fired. For more information on Events, and Event Handlers, please consult
        the Core Programming Guide.</para>
    </section>
    <section>
      <title>Setting up the Viewport in OpenGL</title>
      <para>When the window redraw event is fired, the subgraph is traversed, first visiting the
        Viewport event handler which has an operator attached called <emphasis role="bold"
          >viewPortBeginRender</emphasis>. When viewPortBeginRender is executed, the initial OpenGL
        parameters are set.</para>
      <programlisting language="JavaScript">operator viewPortBeginRender(io Integer width, io Integer height, io Color backgroundColor) {   
  glCullFace(GL_BACK);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);   glViewport(0, 0, width, height);
  glClearColor(backgroundColor.r,
  backgroundColor.g, backgroundColor.b, backgroundColor.a);
  glClear(GL_COLOR_BUFFER_BIT |
  GL_DEPTH_BUFFER_BIT);
}</programlisting>
      <para>The camera event handler is then visited, where the camera projection values are
        computed in the operator <emphasis role="bold">updateCameraProjection</emphasis>.</para>
    </section>
    <section>
      <title>Shaders</title>
      <para>The Fabric SceneGraph rendering system breaks shaders into 2 components, <emphasis
          role="bold">shaders</emphasis> and <emphasis role="bold">materials</emphasis>. The shader
        event handler loads the shader source into the OpenGL driver and compiles the shader
        program. The specification of the shader also includes some meta-data such as the buffers
        required by the shader, and any constant values that must be defined. </para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_03.png" width="70%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Note: To inspect the drawing pipeline you can use the SceneGraph's debugger. Just open
        the <emphasis role="italic">ModelViewer.html</emphasis> sample application, for example,
        open the JavaScript console, and type:</para>
      <programlisting language="JavaScript">FABRIC.displayDebugger();</programlisting>
    </section>
    <section>
      <title>GLSL Uniforms and Attributes</title>
      <para>GLSL shaders define a set of parameters which must be filled out before the geometry can
        be drawn on screen. These 2 sets of requirements are stored in 2 arrays called
        attributeValues, and uniformValues. These arrays are accessible by all child event handlers
        who can determine what data is required by the shader.</para>
      <para>
        <emphasis role="italic">Note: the design of the event handler graph means that 2 different
          nodes can define the same data under the same 'scope name', and the order of visitation
          defines which scope is valid. This enables a single geometry to be rendered multiple times
          using different shaders.</emphasis>
      </para>
    </section>
    <section>
      <title>Materials</title>
      <para>Materials define parameters for the shader program and is used to attach image loaders.
        The Material node in Fabric Engine is generated using meta data associated with the shader.
        XML files are loaded which contain both the GLSL shader code, and meta data that instructs
        the rendering system how to construct material node instances.</para>
      <para>Materials provide data to the shader such as shading parameters, and also provide a
        branch point in the event graph where textures can be loaded and bound prior to traversal
        continuing to the Instance node.</para>
    </section>
    <section>
      <title>Textures</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_04.png" width="60%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Materials which utilize textures must specify which <emphasis role="bold"
          >textureUnit</emphasis> to assign each texture. This process is automated using the
        material system in the SceneGraph. For each textureUnit, a <emphasis role="bold"
          >stub</emphasis> node is generated. This stub node binds in the texture unit that will be
        assigned to the texture. This allows multiple textures to be used on the same material, and
        textures to be shared amongst materials. </para>
    </section>
    <section>
      <title>Instances</title>
      <para>The <emphasis role="bold">instance</emphasis> node represents a drawn piece of geometry.
        To be able to draw geometry on screen, several things bust have happened prior to the draw
        call.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_05.png" width="60%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Geometry rendering happens in the following order:<orderedlist>
          <listitem>
            <para>The shader program is loaded</para>
          </listitem>
          <listitem>
            <para>The the material node is traversed and shader constants set</para>
          </listitem>
          <listitem>
            <para>From the material traversal may continue into the texture stubs and on into the
              texture nodes where the textures are loaded. </para>
          </listitem>
          <listitem>
            <para>From the material node, traversal continues down to the instance node, where the
              matrix for the draw is loaded.</para>
          </listitem>
          <listitem>
            <para>From the instance node, traversal continues down to the geometry node where the
              geometry buffers are loaded and shader uniforms may also be set.</para>
          </listitem>
          <listitem>
            <para>The Geometry is a leaf node, and after the preDescendBindings have been evaluated
              the postDescendBindings follow immediately, and the draw call is executed.</para>
          </listitem>
        </orderedlist></para>
    </section>
    <section>
      <title>Shadows</title>
      <para>Shadow maps are rendered in a pre-draw stage prior to the camera render pass. For each
        light, we render the scene from the point of view of the light, and store the depth
        information in a depth buffer. The depth buffer ID is stored in the light node which is also
        bound to the material. This gives the material access to the lights shadow buffers, enabling
        the correct shadowing of geometry.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_drawing_06.png" width="90%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The red arrow in the diagram represents a binding from the light to the material. This
        binding is what gives the material access to the light's shadow buffer.</para>
    </section>
  </section>
  <section>
    <title>Deferred Rendering Guide</title>
    <para>Deferred rendering describes the process of drawing the viewport's content to several
      framebuffers, and then doing additional passes of rendering utilizing these framebuffers.
      Deferred rendering is tremendously different from standard rendering, since all of the GLSL
      shaders have to store their resulting pixel values into framebuffers. So shaders have to be
      specifically written for deferred rendering.</para>
    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/sg_deferred_01.png" width="90%"/>
        </imageobject>
      </inlinemediaobject></para>
    <para>Deferred rendering allows to perform 2D post effects on the GPU, or additional 3D
      rendering as a post effect.</para>
    <para>Note: The <emphasis role="italic">ToonRendering.html</emphasis> sample applications
      contains an example of using the deferred renderer.</para>
    <section>
      <title>Setting up the Deferred Renderer</title>
      <para>The SceneGraph provides a utility node called the <emphasis role="bold"
          >BasicDeferredRenderer</emphasis>. </para>
      <programlisting language="JavaScript">var renderer = scene.constructNode('BasicDeferredRenderer', {
  addDepth: false, // don't add a depth framebuffer
  colorBuffers: [{name: 'diffuseA, nbChannels: 4}, {name: 'diffuseB', nbChannels: 4}]
});</programlisting>
      <para>Once the renderer is setup, you can setup materials through it. This will ensure that
        the shader and material eventhandlers are connected up correctly within the drawing
        pipeline. You can create <emphasis role="bold">prePassMaterials</emphasis> (for the initial
        draw into framebuffers) or <emphasis role="bold">postPassMaterials</emphasis> (for the
        deferred draw utilizing the framebuffers).</para>
      <programlisting language="JavaScript">var drawMaterial = renderer.addPrePassMaterial('MyDeferredShader', {});
var compositingMaterial = renderer.addPostPassMaterial('MyCompositingShader', {});</programlisting>
    </section>
    <section>
      <title>PrePass Deferred Shaders</title>
      <para>Shaders for a deferred rendering pipline have to write their results in the fragment
        data in GLSL. This will fill the framebuffers. You need to setup the framebuffers
        accordingly when constructing the deferred renderer node. Prepass deferred shaders replace
        the standard shaders from a non-deferred drawing pipeline. Here's an example of a small
        fragment shader that writes red to the first and blue to the second framebuffer.</para>
      <programlisting language="JavaScript">void main(){
  gl_FragData[0] = vec4(1.0,0.0,0.0,1.0);
  gl_FragData[1] = vec4(0.0,0.0,1.0,1.0);
}</programlisting>
    </section>
    <section>
      <title>PostPass Deferred Shaders</title>
      <para>PostPass deferred shaders perform the <emphasis role="bold">compositing</emphasis> of
        the framebuffers to the final displayed image. Typically postpass shaders perform per pixel
        compositing, but they can access all pixels of the framebuffers, since the framebuffers are
        stored as textures on the GPU. Here's an example of a fragment shader which combines both
        diffuse color from the deferred renderer above:</para>
      <programlisting language="JavaScript">uniform sampler2D u_samplerDiffuseA;
uniform sampler2D u_samplerDiffuseB;

void main(){
  vec2 windowCoord = gl_TexCoord[0].st*0.5+0.5;
  gl_FragColor = texture2D( u_samplerDiffuseA, windowCoord ) + texture2D( u_samplerDiffuseB, windowCoord ); 
}</programlisting>
      <para>This will result in a violet rendering of the 3D scene, combined from two different draw
        results.</para>
      <para>Note: Please also see the <emphasis role="italic">DeferredRendering.html</emphasis>
        sample application for an example of a more advanced scenario.</para>
    </section>
  </section>
  <section>
    <title>SceneGraph IO Guide</title>
    <para>Waiting for Jerome's input...!</para>
  </section>
  <section>
    <title>Events Guide</title>
    <para>The SceneGraph provides a system for automatically firing callbacks when certain things
      happen. SceneGraph events are a very powerful mechanism to automate functionality, especially
      since in web applications things can happen asynchronously.</para>
    <section>
      <title>Setting up a node for event handling</title>
      <para>To enable events on a SceneGraph node the <emphasis role="bold"
          >addEventHandlingFunctions</emphasis> method has to be called in the constructor of the
        node.</para>
      <programlisting language="JavaScript">scene.addEventHandlingFunctions(myNodePrivateInterface);</programlisting>
      <para>Once that's done the node can fire events and receive event callbacks. To attach a
        callback to the node, other nodes resp. the scene script can call the <emphasis role="bold"
          >addEventListener</emphasis> method.</para>
      <programlisting language="JavaScript">var myCallback = function(evt) {
  console.log(evt);
  return 'remove';
};
myNodePublicInterface.addEventListener('myEvent', myCallback);</programlisting>
      <para>If the event callback function returns <emphasis role="italic">'remove'</emphasis> the
        callback will be removed from the event listener stack, and won't fire again if the element
        fires another time. If you don't return <emphasis role="italic">'remove'</emphasis> the
        callback will stay attached.</para>
      <para>You can also remove the event callback by calling the <emphasis role="bold"
          >removeEventListener</emphasis> method, which allows to have functions listens to event
        dynamically. So to say you can attach functions and de-attach them again.</para>
      <programlisting language="JavaScript">myNodePublicInterface.removeEventListener('myEvent', myCallback);</programlisting>
      <para>To trigger the event programatically you can call the <emphasis role="bold"
          >fireEvent</emphasis> method on the node. </para>
      <programlisting language="JavaScript">myNodePublicInterface.fireEvent('myEvent', { data: 'myData' });</programlisting>
      <para>This fires all attached event callbacks, and provides the event data to each of the
        callback functions.  This mechasnism is used heavily throughout the SceneGraph.</para>
    </section>
    <section>
      <title>loadSuccess event</title>
      <para>The <emphasis role="bold">ResourceLoadNode</emphasis>, covered in the <emphasis
          role="bold">SceneGraph IO Guide</emphasis> in this document, uses events to dispatch the
        call of event listeners once a resource file is loaded. This mechanism is uses in the
        SceneGraph parsers, but you can also use it for custom scenarios like this:</para>
      <programlisting language="JavaScript">var resourceLoadNode = scene.constructNode('ResourceLoad', {
  url: 'myBinaryFile.bin'
});
resourceLoadNode.addEventListener('loadSuccess', function(evt){
  // attach operators to the resourceLoadNode for parsing...
  return 'remove';
});</programlisting>
      <para>This allows you to automatically continue with the setup of the application once the
        resource file is downloaded and ready.</para>
    </section>
  </section>
  <section>
    <title>Selection Manager Guide</title>
    <para>The SceneGraph comes with a manager for selection, called the <emphasis role="bold"
        >SelectionManager</emphasis>. This manager is the basic implementation, and simply keeps
      track of a collection of selected nodes. It provides the <emphasis role="bold"
        >selectionChanged</emphasis> event for automating UI changes, for example, based on the
      selection.</para>
    <section>
      <title>Basic Selection Management</title>
      <para>The code snippet below sets up the manager, attaches a callback to it and selects as
        well as deselects a single node. This code is the basis for more complex selection
        management.</para>
      <programlisting language="JavaScript">// setup manager and attach event callback
var selectionMgr = scene.constructManager('SelectionManager');
selectionMgr.addEventListener('selectionChangesd',function(evt) {
  console.log(evt.selection);
});

// select a node and deselect it again
selectionMgr.addToSelection(myNode);
selectionMgr.removeFromSelection(myNode);</programlisting>
    </section>
    <section>
      <title>Viewport Selection Manager</title>
      <para>The <emphasis role="bold">ViewportSelectionManager</emphasis> works by providing a new
          <emphasis role="bold">Instance</emphasis> node, called the <emphasis role="bold"
          >SelectableInstance</emphasis>. It contains a selection state as well as an additional
        material, that indicates the selection during drawing.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_selection_01.png" width="70%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>When a SelectableInstance node is hovered, the material on the node changes to the
          <emphasis role="italic">highlighted</emphasis> material. Once the node is selected the
        material changes to the <emphasis role="italic">selected</emphasis> material. </para>
      <programlisting language="JavaScript">// create the materials
var normalMaterial = scene.constructNode('FlatMaterial', { color: FABRIC.RT.rgb(0.0, 0.0, 1.0, 1) });
var highlightMaterial = scene.constructNode('FlatMaterial', { color: FABRIC.RT.rgb(0.7, 0.7, 0.7, 1) });
var selectedMaterial = scene.constructNode('FlatMaterial', { color: FABRIC.RT.rgb(1.0, 0.0, 0.0, 1) });

// create a selectable instance
var myInstance = scene.constructNode('SelectableInstance', {
  transformNode: myTransform,
  geometryNode: myGeometry,
  materialNode: normalMaterial,
  highlightMaterial: highlightMaterial,
  selectMaterial: selectedMaterial
});

// setup manager and attach event callback
var selectionMgr = scene.constructManager('ViewportSelectionManager');
selectionMgr.addEventListener('selectionChangesd',function(evt) {
  console.log(evt.selection);
});

// select a node and deselect it again
selectionMgr.addToSelection(myInstance);
selectionMgr.removeFromSelection(myInstance);</programlisting>
      <para><emphasis role="italic">Note: The Selection.html sample application contains an example
          of how to use selection in the SceneGraph.</emphasis></para>
    </section>
    <section>
      <title>Selection Manipulation Manager</title>
      <para>The <emphasis role="bold">SelectionManipulationManager</emphasis> provides an additional
        mechanism for selection based manipulation. For further details on the way manipulation
        works in the SceneGraph please refer to the <emphasis role="bold">Manipulation
          Guide</emphasis> in this document. The SelectionManipulationManager itself is not taking
        care of the selection management, therefore you need to specify the SelectionManager during
        its construction. The SelectionManipulationManager just takes care of setting up a group
        manipulation, that toggles on and off based on selection changes as well as centers the
        manipulator in the center of the selected objects.</para>
      <programlisting language="JavaScript">var manipulationMgr = scene.constructManager('SelectionManipulationManager', {
  selectionManager: selectionMgr,
  manipulators: undefined // here you can specify an array of manipulators to manage
});</programlisting>
      <para>By providing a list of manipulators to the <emphasis role="italic"
          >manipulators</emphasis> option, you can define the kind of manipulations you want the
        manager to take care of. If you don't specify anything, the manipulation will default to to
        a screen space translation.</para>
    </section>
  </section>
  <section>
    <title>Manipulation Guide</title>
    <para>The SceneGraph provides a solid framework for manipulation. While a series of transform
      manipulators are provided, you can build your own manipulators. This document includes a
        <emphasis role="bold">Tutorial for building a custom manipulator</emphasis>.</para>
    <para>Manipulation in the SceneGraph works by modifying the dependency graph's data in
      JavaScript. For this, several steps of execution are required:<orderedlist>
        <listitem>
          <para>On MouseDown: Gather all of the current relevant values (snapshot) and attach event
            callbacks for MouseMove</para>
        </listitem>
        <listitem>
          <para>On MouseMove: Compare current values with the snapshot and change the graph
            accordingly</para>
        </listitem>
        <listitem>
          <para>On MouseUp: Remove the MouseMove event callbacks.</para>
        </listitem>
      </orderedlist></para>
    <section>
      <title>Setting up a Manipulator</title>
      <para>Manipulators require <emphasis role="bold">RayCasting</emphasis> to be enable in the
        viewport, since it needs to determine which objects are hit below the mouse's position. To
        enable RayCasting, provide the following options when constructing the viewport:</para>
      <programlisting language="JavaScript">var viewport = scene.constructNode('Viewport', {
  windowElement: document.getElementById('FabricContainer'),
  enableRaycasting: true,
  rayIntersectionThreshold: 0.8
});</programlisting>
      <para>Manipulators operate on Instance nodes, so you first have to create an instance node to
        be able to attach a manipulator. Manipulators can operate on any member on any dependency
        graph node, but since typically manipulation in 3D affects the transforms of objects, all of
        the provided manipulators in the SceneGraph operate on the <emphasis role="bold"
          >globalXfo</emphasis> member of the transform node.</para>
      <programlisting language="JavaScript">// create an instance out of geometry, transform and material
var instance = scene.constructNode('Instance', {
  geometryNode: myGeometry,
  transformNode: myTransform,
  materialNode: myMaterial
});

// create a manipulator for the instance node
var manipulator = scene.constructNode('3AxisTranslationManipulator', {
  targetNode: instance,
  size: 10,
  linearTranslationManipulators: true,
  planarTranslationManipulators: true,
  screenTranslationManipulators: true
});</programlisting>
      <para>For a list of all of the manipulators available and their options please refer to the
          <emphasis role="bold">SceneGraph Node Reference</emphasis> in this document.</para>
      <para><emphasis role="italic">Note: The Manipulators.html sample application contains an
          example of how to use manipulation in the SceneGraph.</emphasis></para>
    </section>
  </section>
  <section>
    <title>Undo / Redo Guide</title>
    <para>Undo and Redo functionality in the SceneGraph can be achieved by constructing the
        <emphasis role="bold">UndoManager</emphasis> and pushing <emphasis role="bold"
        >Transactions</emphasis> to it. A transaction is a dictionary containing callbacks for
        <emphasis role="bold">onClose</emphasis>, <emphasis role="bold">onUndo</emphasis> and
        <emphasis role="bold">onRedo</emphasis>. The SceneGraph's manipulation system provides these
      kinds of transactions already, but you can implement your own.</para>
    <para>To undo or redo a transaction, simply call the on the <emphasis role="bold"
        >undo</emphasis> and <emphasis role="bold">redo</emphasis> methods of the  of the
      UndoManager.</para>
    <programlisting language="JavaScript">// create an undo manager
var undoMgr = scene.constructManager('UndoManager');

// create a value to be changed
var value = 10;
var prevValue = value;
var newValue;

// push a transaction to it
undoMgr.addTransaction({
  onClose: function() {
    newValue = value;
  },
  onUndo: function() {
    value = prevValue;
  },
  onRedo: function() {
    value = newValue;
  }
});

// change the value
value = 20;

// close the transaction
undoMgr.closeTransaction();

// undo the change
undoMgr.undo();</programlisting>
    <para><emphasis role="italic">Note: The Undo.html sample application contains an example of how
        to use Undo and Redo in the SceneGraph.</emphasis></para>
    <section>
      <title>Using Undo and Redo with Manipulation</title>
      <para>The manipulation system already supports undo. Since you can have multiple UndoManagers
        in an application, you can optionally provide the UndoManager to the construction options of
        the manipulators, but even if you didn't specify it the first created undomanager will be
        used for manipulation.</para>
      <programlisting language="JavaScript">// create an undo manager
var undoMgr = scene.constructManager('UndoManager');

// create a manipulator for the instance node
var manipulator = scene.constructNode('3AxisTranslationManipulator', {
  targetNode: instance,
  size: 10,
  linearTranslationManipulators: true,
  planarTranslationManipulators: true,
  screenTranslationManipulators: true,
  undoManager: undefined // optionally you can specify it here, in case you have more than one
});</programlisting>
    </section>
  </section>
  <section>
    <title>Websockets Guide</title>
    <para>The SceneGraph provides an easy way of using websockets to automate client - server -
      client communication. For this a node websocket server is required. For a sample
      implementation, please see our github project
        <uri>http://github.com/fabric-engine/websocket-server</uri>.</para>
    <para>For test scenarios you might as well use node websocket server located at
        <uri>ws.fabric-engine.com</uri>.</para>
    <section>
      <title>WebSocketManager</title>
      <para>Before you can send or receive messages you need to setup the <emphasis role="bold"
          >WebSocketManager</emphasis>. Each session uses a unique key, which is determined
        automatically, however you can specify it yourself to ensure that all users of the
        application are able to communicate with each other. </para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_websockets_01.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Since the web socket connection has to be established before message handlers can be
        setup, the constructor also takes in the <emphasis role="bold">onOpenCallBack</emphasis>
        option, which is executed once the connection is up.</para>
      <programlisting language="JavaScript">// create a web socket manager
var websocketMgr = scene.constructManager('WebSocketManager', {
  serverUrl: 'ws.fabric-engine.com',
  contextID: 'myOwnCustomKey',
  onOpenCallBack: function() {
    console.log('Connection established');
  }
});</programlisting>
    </section>
    <section>
      <title>Sending Messages</title>
      <para>To send message, ensure that the connection has been established. Otherwise the sending
        of the message will fail. Messages contain a name, data as well as an optional recipient. If
        you don't specify the recipient the message will be send to all of the participants of the
        current session.</para>
      <programlisting language="JavaScript">websocketMgr.sendMessage('askQuestion', { question: 'What\'s your name?' });</programlisting>
      <para>The data can contain any JSON compliant struct. The WebSocketManager encodes it and
        decodes it automatically.</para>
    </section>
    <section>
      <title>Receiving Messages</title>
      <para>To receive messages you need to setup callbacks for each message type on the
        WebSocketManager. Reception message callbacks themselves can also send messages again of
        course.</para>
      <programlisting language="JavaScript">// setup a message callback for the 'askQuestion' message
websocketMgr.addMessageCallBack('askQuestion', function(message) {
  if(message.data.question == 'What\'s your name?') {
    // reply just to the sender of this message
    var data = {
      question: message.data.question,
      answer: 'My name is Fabric.'
    };
    websocketMgr.sendMessage('replyToQuestion', data, message.sourceID);
  } else
    console.log('I don\'t know how to answer this question: '+message.data.question);
});

// setup a message callback for the 'replyToQuestion' message
websocketMgr.addMessageCallBack('replyToQuestion', function(message) {
  console.log('I asked: '+message.data.question);
  console.log(message.sourceID+' replied: '+message.data.answer);
});</programlisting>
      <para><emphasis role="italic">Note: The WebSockets.html sample application demonstrates how to
          synchronize camera manipulation between clients.</emphasis></para>
    </section>
  </section>
  <section>
    <title>Bullet Physics Guide</title>
    <para>The Fabric Engine SceneGraph contains a reference implementation of the Bullet Physics
      simulation engine (<uri>http://www.bulletphysics.org</uri>). It allows to create several
      different shapes, rigid bodies, soft bodies as well as constraints between them.</para>
    <para>Bullet requires custom shapes to be constructed for collision. They can be different from
      the ones you see in the viewport, so for example you could create a box shape for a complex
      mesh based on its bounding box for a faster simulation.</para>
    <para>Bullet operates on the SceneGraph's transform nodes.</para>
    <section>
      <title>Creating the Bullet world</title>
      <para>Each simulation requires a world to run in. You may create several worlds, but only
        object within the same world will effect each other.</para>
      <programlisting language="JavaScript">var world = scene.constructNode('BulletWorldNode');</programlisting>
      <para>Once the world is set up you can start creating shapes and simulation elements.</para>
    </section>
    <section>
      <title>Creating Collision Shapes</title>
      <para>The SceneGraph's Bullet implementation supports several basic shapes. Shapes are
        identified by their name. The name has to be unique, using the same name several times will
        result in an error. You can later use the shapes' names to construct rigid bodies. These are
        the basic shapes you can construct:</para>
      <programlisting language="JavaScript">world.addShape('myBox', FABRIC.RT.BulletShape.createBox(new FABRIC.RT.Vec3(1.0,1.0,1.0)));
world.addShape('mySphere', FABRIC.RT.BulletShape.createBox(1.0 /* radius */));
world.addShape('myCylinder', FABRIC.RT.BulletShape.createBox(1.0 /* radius */, 1.0 /* height */));
world.addPlane('myPlane', FABRIC.RT.BulletShape.createBox(new FABRIC.RT.Vec3(0.0,1.0,0.0)));</programlisting>
      <para>Aside from the standard shapes you can also construct complex shapes based on SceneGraph
        geometry nodes. So for example, given the torus triangles node, you can construct either a
        convex hull collision shape or a triangle mesh, or a GImpact shape. Convex hull shapes are
        very fast and robust, but they don't provide actual shape collision. triangle mesh shapes
        are very slow for moving objects, and should be used only for complex ground shapes. GImpact
        shapes provide accurate collision for moving objects which need to support actual shape
        collision (inclusing concave shapes).</para>
      <programlisting language="JavaScript">var torus = scene.constructNode('Torus'); // this is a triangles node
world.addShape('myConvexHull',FABRIC.RT.BulletShape.createConvexHull(torus));
world.addShape('myTriangleMesh',FABRIC.RT.BulletShape.createTriangleMesh(torus));
world.addShape('myGImpact',FABRIC.RT.BulletShape.createGImpact(torus));</programlisting>
    </section>
    <section>
      <title>Creating Rigid Bodies</title>
      <para>Once you have constructed the shapes, you can create rigid bodies in the world. Rigid
        bodies have several settings, but the main important option is the <emphasis role="bold"
          >mass</emphasis>. If you set the mass to 0.0, the rigid body will be passive. This means
        Fabric Engine will continue to drive the transform of the rigid body, and it will affect the
        Bullet world. If the mass is set to > 0.0 the rigid body is active, and is purely affected
        by the Bullet simulation.</para>
      <programlisting language="JavaScript">// construct a passive plane
world.addRigidBody('ground', new FABRIC.RT.BulletRigidBody({
  mass: 0.0
}), 'myPlane');

// construct a passive plane
world.addRigidBody('torusRbd1', new FABRIC.RT.BulletRigidBody({
  mass 1.0,
  friction: 0.6,
  restitution: 0.2, // bouncyness
  transform: new FABRIC.RT.Xfo({
    tr: new FABRIC.RT.Vec3(0.0,4.0,0.0)
  })
}), 'myConvexHull');
</programlisting>
      <para>Note that we didn't connect up the rigid bodies to any element in the SceneGraph yet.
        Right now these objects are purely part of the world and are not visibile to the viewport at
        all. To create a transform that is connected to the Bullet world, you can construct a
          <emphasis role="bold">BulletRigidBodyTransform</emphasis> node. The code below will setup
        a torus which is moving and visible in the viewport.</para>
      <para>Once you have constructed the shapes, you can create rigid bodies in the world. Rigid
        bodies have several settings, but the main important option is the <emphasis role="bold"
          >mass</emphasis>. If you set the mass to 0.0, the rigid body will be passive. This means
        Fabric Engine will continue to drive the transform of the rigid body, and it will affect the
        Bullet world. If the mass is set to > 0.0 the rigid body is active, and is purely affected
        by the Bullet simulation. Also note that you can create multiple rigid bodies using the same
        collision shape.</para>
      <programlisting language="JavaScript">// create a transform node driven by bullet
var bulletTransform = scene.constructNode('BulletRigidBodyTransform', {
  name: 'torusRbd2',
  bulletWorldNode: world,
  shapeName: 'myConvexHull',
  rigidBody: new FABRIC.RT.BulletRigidBody({
    transform: new FABRIC.RT.Xfo({
      tr: new FABRIC.RT.Vec3(0.0,4.0,0.0)
    })
  })
});

// create an instance to draw the torus
var instance = scene.constructNode('Instance', {
  transformNode: bulletTransform,
  geometryNode: torus,
  materialNode: scene.constructNode('PhongMaterial')
});</programlisting>
    </section>
    <section>
      <title>Creating Soft Bodies</title>
      <para>While Rigid Bodies represent hard surfaces, Bullet also supports deforming surfaces,
        called <emphasis role="bold">Soft Bodies</emphasis>. These bodies contain the shape as well,
        so they don't require a collision shape name for construction. Soft bodies don't use a
        transform, they are applied as a deformation on top of the geometry node.</para>
      <programlisting language="JavaScript">// create a softbody
var torusSoftBody = world.addSoftBody('torusSbd1',new FABRIC.RT.BulletSoftBody({
  trianglesNode: torus,
  transform: FABRIC.RT.xfo({
    tr: new FABRIC.RT.Vec3(0,16,0)
  }),
  stiffness: 0.1, // spring stiffness
  friction: 0.5, // dynamic friction
  conservation: 0.0, // volume conservation
  recover: 0.01, // recover original shape per frame
  pressure: 5    // internal pressure
}));

// create an instance to draw the deforming
// torus. no transform specified since the 
// transform is included in the deformation
var instance = scene.constructNode('Instance', {
  geometryNode: torusSoftBody,
  materialNode: scene.constructNode('PhongMaterial')
});</programlisting>
    </section>
    <section>
      <title>Creating Constraints</title>
      <para>Constraints are connections between rigid bodies. The SceneGraph supports three types of constraints:<itemizedlist>
          <listitem>
            <para>Point2Point: A ball and socket connection with 360 degrees of freedom</para>
          </listitem>
          <listitem>
            <para>Hinge: A single axis rotation connection with 360 degrees of freedom</para>
          </listitem>
          <listitem>
            <para>Slider: A single axis translation connection with 0 degrees of freedom</para>
          </listitem>
        </itemizedlist></para>
      <para>For creating a constraint you need to specify the names of the two bodies to be
        connected as well as the constraint's options.</para>
      <programlisting language="JavaScript">world.addConstraint('myBallSocket',FABRIC.RT.BulletConstraint.createPoint2Point({
  pivotA: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,4.0,0)}),
  pivotB: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,-4.0,0)}),
}),'torusRbd1','torusRbd2');

world.addConstraint('myHinge',FABRIC.RT.BulletConstraint.createHinge({
  pivotA: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,4.0,0)}),
  pivotB: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,-4.0,0)}),
}),'torusRbd1','torusRbd2');

world.addConstraint('mySlider',FABRIC.RT.BulletConstraint.createSlider({
  pivotA: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,4.0,0)}),
  pivotB: FABRIC.RT.xfo({tr: new FABRIC.RT.Vec3(0,-4.0,0)}),
}),'torusRbd1','torusRbd2');</programlisting>
    </section>
    <section>
      <title>Creating Anchors</title>
      <para>Anchors are connections between rigid bodies and soft bodies. Aside from the names of
        the rigid body and the soft body it is also required to specify an array of point indices on
        the softbody to attach the anchor to.</para>
      <programlisting language="JavaScript">world.addAnchor('myAnchor',new FABRIC.RT.BulletAnchor({
  softBodyNodeIndices: [0,1,2,3,4,5]
  }),'torusRbd1','torusSbd1'
);</programlisting>
    </section>
    <section>
      <title>Array functionality</title>
      <para>All <emphasis role="bold">add</emphasis> methods on the BulletWorldNode support single
        obbjects as well as arrays. This means that you can construct multiple rigid bodies at the
        same time, by providing an array of bodies rather than just a single one. This also works
        for constraints. For further details, please have a look at the <emphasis role="italic"
          >Constraints.html</emphasis> or <emphasis role="italic">StackingBoxes.html</emphasis>
        sample applications.</para>
    </section>
  </section>
  <section>
    <title>SceneGraphNode Reference</title>
    <para>In this section you can find documentation for all of the current SceneGraphNodes provided
      by the JavaScript SceneGraph. For each node a short description is provided, as well as a
      reference to its options. Only the methods on the public interface are documented here. For
      further information on the private interfaces please refer to the JavaScript file providing
      the respective nodes.</para>
    <section>
      <title>SceneGraph.js</title>
      <section>
        <title>SceneGraphNode</title>
        <para>ParentNode: <emphasis role="bold">None</emphasis></para>
        <para>This is the base node for all nodes in the SceneGraph. It is never constructed
          directly, but all other nodes use it as their base. The SceneGraphNode is responsible for
          constructing the dependency graph nodes and eventhandler nodes in the core, as well as
          deploying all of the base features provided by the SceneGraph, such as eventhandling
          etc.</para>
        <para>Event related functions are only available on certain instances of the SceneGraphNode.
          This depends on the construction and if <emphasis role="bold"
            >addEventHandlingFunctions</emphasis> was called.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>SceneGraphNode Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>name</entry>
                <entry>The name of the SceneGraph node. If not specified, it will default to its
                  type.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>SceneGraphNode Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getName()</entry>
                <entry>Returns the name of the node.</entry>
              </row>
              <row>
                <entry>setName(name)</entry>
                <entry>Sets the new name of the node.</entry>
              </row>
              <row>
                <entry>addEventListener(event, func)</entry>
                <entry>Adds a new function to the given event name.</entry>
              </row>
              <row>
                <entry>removeEventListener(event,func)</entry>
                <entry>Removes a function from listening to a given event name.</entry>
              </row>
              <row>
                <entry>fireEvent(event)</entry>
                <entry>Executes all of the listening functions of a given event name.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>ResourceLoad</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>This node is used for loading external resources into Fabric Engine. Resources can be
          images, 3D files or any external binary content. The node supports loading the data to
          memory or storing it to a temporary file (default). The node also fires an <emphasis
            role="italic">loadSuccess</emphasis> event once the load is finished, so event listener
          can be attached accordingly.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>ResourceLoad Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>url</entry>
                <entry>The url of the external data resource</entry>
              </row>
              <row>
                <entry>storeDataAsFile</entry>
                <entry>If true the data is stored to a temporary file, otherwise the content is
                  stored in memory.</entry>
              </row>
              <row>
                <entry>redrawOnLoad</entry>
                <entry>If true the viewport will be refreshed automatically once loading is
                  finished.</entry>
              </row>
              <row>
                <entry>blockRedrawingTillResourceIsLoaded</entry>
                <entry>If true the viewport will not refresh during the load of the
                  resource.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>ResourceLoad Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>setUrl(url, force)</entry>
                <entry>Sets the new URL for the resource. If force is true the node is force to
                  evaluate immediately.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Geometry.js</title>
      <section>
        <title>Geometry</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The Geometry node is a base abstract node for all geometry nodes. The Geometry node
          provides basic OpenGL Vertex Buffer Object (VBO) management and other services common to
          all type of geometry. The Geometry node provides a uniformsDependency Graph node which is
          used to contain non-vertex data for the geometry. Non vertex data might be paramters used
          in a generator opator such as the radius of a sphere. The Geometry node also provides a
          Vertex Attribute Dependency Graph node. All per-vertex data is stored in the vertex dgnode
          as a sliced node. Each slice in the sliced node contains the vertex data for one vertex.
          This special vertex attribute node ensures that every vertex has the same attributes, and
          by simply adding a new data member, all verticies aquire the new data mamber. This model
          maps well to GPU memory layouts where all vertex attributes must have identical counts to
          evaluate efficiently. This model enables efficient multi-threaded operators to be applied
          to all vertices in a mesh. The trade-off is lightly higher memory usage, as shared vertex
          attributes are duplicated to each vertex.</para>
        <db:para>Each of the derrived geometries must provide specialiazed drawing and raycasting
          operators to enable the derived geometry to inetgrate with the rendering and interaction
          systems of the Fabric Scene Graph. The combination of flexible vertex attributes sets, and
          custom draw operator makes it easy to define custom geometry types.</db:para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Geometry Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>createBoundingBoxNode</entry>
                <entry>Determines whether a bounding box node is constructed. </entry>
              </row>
              <row>
                <entry>drawable</entry>
                <entry>Determines whether the redraw event hander is set up and VBOs uploaded for
                  each vertex atribute. Note: drawing would not be required for a collision mesh for
                  example</entry>
              </row>
              <row>
                <entry>dynamicIndices</entry>
                <entry>Specifies whether the indices buffer should be dynamic. Geometry which has a
                  dynamcially chaning topoloy would set this to true. </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Geometry Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>addUniformValue()</entry>
                <entry>Adds a new member to the uniforms Dependency Graph node.</entry>
              </row>
              <row>
                <entry>addVertexAttributeValue(name, type, attributeoptions)</entry>
                <entry>Adds a new vertex attribute to the geometry. The options object passed in can
                  specify ether the given vertex attribute should be used to generate a VBO using
                  the parameter genVBO: true. </entry>
              </row>
              <row>
                <entry>reloadVBO(name)</entry>
                <entry>Manually triggers an re-uploading of the vertex buffer to the GPU.</entry>
              </row>
              <row>
                <entry>setAttributeDynamic(name)</entry>
                <entry>Sets the given attribute to use Dynamic OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </entry>
              </row>
              <row>
                <entry>setAttributeStatic(name)</entry>
                <entry>Sets the given attribute to use Static OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </entry>
              </row>
              <row>
                <entry>getVertexCount</entry>
                <entry>Sets the number of vertices stored in the attributes node.</entry>
              </row>
              <row>
                <entry>setVertexCount</entry>
                <entry>Gets the number of vertices stored in the attributes node.</entry>
              </row>
              <row>
                <entry>loadGeometryData</entry>
                <entry>This method is used to load data into the geometry node. The Collada parser
                  uses this method to load parsed geometry data.s</entry>
              </row>
              <row>
                <entry>getBoundingBox</entry>
                <entry>Returns the corner coordinates of the bounding box for this node.s</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>GeometryDataCopy</title>
        <para>ParentNode: <emphasis role="bold">Geometry</emphasis></para>
        <para>The geometry data copy node provides a methd to create  geometries derived from a base
          geometry. Per-Point operators can be applied to the Geometry Data Copy, and these
          operators can reference the base geometry as an input. The GeometryDataCopy is a base type
          used to construct specialized deforming geometries. The GeometryDataCopy can be used to
          derive a new Point, Lines, or Triangle mesh as it only provides generic double buffering
          and operator evaluation of vertex attributes.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>GeometryDataCopy Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>baseGeometryNode</entry>
                <entry>The geometry to use as the base for this derived geometry.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>GeometryDataCopy Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>setBaseGeometry(geometry)</entry>
                <entry>Sets the geometry to be used as base geometry.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Points</title>
        <para>ParentNode: <emphasis role="bold">Geometry</emphasis></para>
        <para>The Points node creates a specialization of the gometry node for drawing point. It
          simply does this by adding a 'positions' vertex attribute, and providing drawing operators
          that issue the appropriate OpenGL draw comments during rendering.</para>
      </section>
      <section>
        <title>Lines</title>
        <para>ParentNode: <emphasis role="bold">Geometry</emphasis></para>
        <para>The Lines node creates a specialization of the gometry node for drawing lines. It
          simply does this by adding a 'positions' vertex attribute, and an indices Uniform value,
          and providing drawing operators that issue the appropriate OpenGL draw comments during
          rendering.</para>
      </section>
      <section>
        <title>LineStrip</title>
        <para>ParentNode: <emphasis role="bold">Geometry</emphasis></para>
        <para>The LineStrip node creates a specialization of the gometry node for drawing line
          strips. The only difference between Lines and LineStrip is the drawing operator provided
          assumes a GL_LINESTRIP layout of the vertex indices array.</para>
      </section>
      <section>
        <title>Triangles</title>
        <para>ParentNode: <emphasis role="bold">Geometry</emphasis></para>
        <para>The Triangles node creates a specialization of the gometry node for drawing triangles.
          It does this by adding several vertex attrinbutes that are used in drawing triangles. The
          'positions' and 'normal' vertex attributes are provided, along with optional VU sets
          ('uvs0'), and tangents.</para>
      </section>
      <section>
        <title>Instance</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The Instance Scene Graph node represents a drawn geometry. The Instance node is used
          to bind a Geomerty to a Transform and a Material and draw the results on screen. When a
          geometry is assigned to an instance node, the Instance node requests the geometries 'draw
          operator', and assigns the draw operator to the instance's draw event handler. The
          Instance node also handles raycasting of geometries. When a material is assigned to an
          Instance, the instance connectes its draw event handler to the materials draw event
          handler. This ensures that when the matierl is set up for rendering, the draw event
          handler of the Instance is then invoked causing the drawing of the geometry.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Instance Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>transformNode</entry>
                <entry>The transform node to use to control the transform the geometry in the
                  scene.</entry>
              </row>
              <row>
                <entry>transformNodeMember</entry>
                <entry>TODO: remove me</entry>
              </row>
              <row>
                <entry>transformNodeIndex</entry>
                <entry>TODO: remove me</entry>
              </row>
              <row>
                <entry>constructDefaultTransformNode</entry>
                <entry>The Instance node will construct a default transform node if none is
                  provided. </entry>
              </row>
              <row>
                <entry>geometryNode</entry>
                <entry>The Geometry node that will be used in drawing/racasting</entry>
              </row>
              <row>
                <entry>transformNode</entry>
                <entry>The Transform node that will be used in drawing/raycasting.</entry>
              </row>
              <row>
                <entry>materialNode</entry>
                <entry>The Material node that will be used in drawing.</entry>
              </row>
              <row>
                <entry>enableRaycasting</entry>
                <entry>The option to enable/disable raycasting for this instance</entry>
              </row>
              <row>
                <entry>enableDrawing</entry>
                <entry>The option to enable/disable drawing for this instance</entry>
              </row>
              <row>
                <entry>raycastOverlaid</entry>
                <entry>In some cases, it is required that a given geometry returns raycast results
                  even if occlueded by other geometries. This is the case when a geometry is being
                  used as a Manipulator widget. The Manipulator widgets are drawn over the top of
                  all geometry, and must also respond to mouse events. This option causes the
                  Instance to alsways return a raycast result with a distance of 0. </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>GeometryDataCopy Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="248.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getGeometryNode/setGeometryNode</entry>
                <entry>Gets/Sets the Geometry node</entry>
              </row>
              <row>
                <entry>getTransformNode/setTransformNode</entry>
                <entry>Gets/Sets the Transform node</entry>
              </row>
              <row>
                <entry>getMaterialNode/setMaterialNode</entry>
                <entry>Gets/Sets the Material node</entry>
              </row>
              <row>
                <entry>getLayerManagerNode/setLayerManagerNode</entry>
                <entry>Gets/Sets the Layer Manager node. When an Instance is assigned to a layer in
                  a Layer Manager, it binds an operator to its dgnode that drives the draw toggle
                  from the value of the assigned layer in the layer manger. This means that if the
                  layer is disabled, all Instances assigned to that layer become disabled.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>LayerManager</title>
        <para>ParentNode: <emphasis role="bold"/></para>
        <para>The Layer Manager is a very simply Manager for contolling the drawing of many
          Instances at once. When an I</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>LayerManager Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>addLayer(geometry)</entry>
                <entry>Adds a new Boolean value to the Layer Manger with the given name. Each
                  assigned layer generates getter and setter functions to toggle the state of the
                  drawing for that layer. </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Primitives.js</title>
      <para>The Primitives are generated geometries, using operators to procedurally generate the
        data of the geometry. They expose methods to access and modify the paramters used by the
        generator operators.</para>
      <section>
        <title>LineVector</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The LineVector node simply draws a static line between 2 predefined points.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>LineVector Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>from</entry>
                <entry>The start point of the line in the coordinte space of the line.</entry>
              </row>
              <row>
                <entry>to</entry>
                <entry>The end point of the line in the coordinte space of the line.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Cross</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The Cross node uses an operator to control the size and position of the 6 points that
          make up the 3 orthogonal line segments that make up the cross. The cross is drawn as 3
          line degments aligned to the majior axes of the local coordinate frame.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cross Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>size</entry>
                <entry>The size of the generated cross.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cross Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getSize/setSize</entry>
                <entry>Accessor methods for the size of the cross</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Axis</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The Axis node uses an operator to draw a set of labeled coordinate system axis. The
          axes are labeled 'X', 'Y', and 'Z'</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Axis Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>size</entry>
                <entry>The size of the generated cross.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Axis Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getSize/setSize</entry>
                <entry>Accessor methods for the size of the cross</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Rectangle</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The Rectangle primitive displays a rectangle aligned to the X/Z plane.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Rectangle Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>length</entry>
                <entry>The length of the generated rectangle in the local X axis.</entry>
              </row>
              <row>
                <entry>width</entry>
                <entry>The width of the generated rectangle in the local Z axis.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Rectangle Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="252pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getLength/setLength</entry>
                <entry>Accessor methods for the length of the rectangle primitive</entry>
              </row>
              <row>
                <entry>getWidth/setWidth</entry>
                <entry>Accessor methods for the width of the rectangle primitive</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>BoundingBox</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The BoundingBox primitive displays a box using top left, and bottom right coordinates
          to control the size and offset of the box.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>BoundingBox Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>bboxmin</entry>
                <entry>The length of the generated rectangle in the local X axis.</entry>
              </row>
              <row>
                <entry>bboxmax</entry>
                <entry>The width of the generated rectangle in the local Z axis.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>BoundingBox Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="252pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getBoundingBoxMin/setBoundingBoxMin</entry>
                <entry>Accessor methods for the min coordinates of the bounding box.</entry>
              </row>
              <row>
                <entry>getBoundingBoxMax/setBoundingBoxMax</entry>
                <entry>Accessor methods for the max coordinates of the bounding box.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Grid</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The Grid primitive displays a 3 dimensional grid</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Grid Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>size_x</entry>
                <entry>The size of the grid in the X axis</entry>
              </row>
              <row>
                <entry>size_y</entry>
                <entry>The size of the grid in the Y axis</entry>
              </row>
              <row>
                <entry>size_z</entry>
                <entry>The size of the grid in the Z axis</entry>
              </row>
              <row>
                <entry>sections_x</entry>
                <entry>The number of sections of the grid along the X axis</entry>
              </row>
              <row>
                <entry>sections_y</entry>
                <entry>The number of sections of the grid along the Y axis</entry>
              </row>
              <row>
                <entry>sections_z</entry>
                <entry>The number of sections of the grid along the Z axis</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>CameraPrimitive</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The CameraPrimitive is used to draw a Camera icon on screen. The camera primitive
          draws a box with a cone attached indicating the oriantation of the camera. This can be
          used to visualize cameras in the 3d viewport.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>CameraPrimitive Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>size</entry>
                <entry>The size of the generated cross.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>CameraPrimitive Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getSize/setSize</entry>
                <entry>Accessor methods for the size of the drawn primitive</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Circle</title>
        <para>ParentNode: <emphasis role="bold">Lines</emphasis></para>
        <para>The Circle primitive can be used to draw either a circle, or an arc if a the arc ancle
          specified is less than 2pi.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>CameraPrimitive Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>radius</entry>
                <entry>The size of the generated cross.</entry>
              </row>
              <row>
                <entry>arcAngle</entry>
                <entry>the angle, specified in radians of the drawn Circle. By default the 'Circle'
                  draws a complete circle, however, an arc can be drawn by specifying a value less
                  than 2 pi.</entry>
              </row>
              <row>
                <entry>numSegments</entry>
                <entry>The number of line segments used to draw the circle/arc.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>CameraPrimitive Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getRadius/setRadius</entry>
                <entry>Accessor methods for the radius of the drawn circle/arc</entry>
              </row>
              <row>
                <entry>getArcAngle/setArcAngle</entry>
                <entry>Accessor methods for the angle of the drawn circle/arc</entry>
              </row>
              <row>
                <entry>getNumSegments/setNumSegments</entry>
                <entry>Accessor methods for the number of line segments use when drawing the
                  arc/circle</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Plane</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Plane primitive draws </para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Plane Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>length</entry>
                <entry>The length of the plane in the X axis</entry>
              </row>
              <row>
                <entry>width</entry>
                <entry>The width of the plane in the Z axis</entry>
              </row>
              <row>
                <entry>lengthSections</entry>
                <entry>The number of length sections to use when building the plane.</entry>
              </row>
              <row>
                <entry>widthSections</entry>
                <entry>The number of width sections to use when building the plane</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Plane Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getLength/setLength</entry>
                <entry>Accessor methods for the length of the drawn plane</entry>
              </row>
              <row>
                <entry>getWidth/setWidth</entry>
                <entry>Accessor methods for the width of the drawn plane</entry>
              </row>
              <row>
                <entry>getLengthSections/setLengthSections</entry>
                <entry>Accessor methods for the number of length sections to use when drawing the
                  plane.</entry>
              </row>
              <row>
                <entry>getWidthSections/setWidthSections</entry>
                <entry>Accessor methods for the number of width sections to use when drawing the
                  plane.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Cuboid</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Cuboid primitive draws a cuboid.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cuboid Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>length</entry>
                <entry>The length of the cuboid in the X axis</entry>
              </row>
              <row>
                <entry>width</entry>
                <entry>The width of the cuboid in the Z axis</entry>
              </row>
              <row>
                <entry>height</entry>
                <entry>The height of the cuboid in the Y axis</entry>
              </row>
              <row>
                <entry>lengthSections</entry>
                <entry>The number of length sections to use when building the cuboid.</entry>
              </row>
              <row>
                <entry>widthSections</entry>
                <entry>The number of width sections to use when building the cuboid</entry>
              </row>
              <row>
                <entry>heightSections</entry>
                <entry>The number of height sections to use when building the cuboid</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cuboid Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getLength/setLength</entry>
                <entry>Accessor methods for the length of the drawn cuboid</entry>
              </row>
              <row>
                <entry>getWidth/setWidth</entry>
                <entry>Accessor methods for the width of the drawn cuboid</entry>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>getLengthSections/setLengthSections</entry>
                <entry>Accessor methods for the number of length sections to use when drawing the
                  cuboid.</entry>
              </row>
              <row>
                <entry>getWidthSections/setWidthSections</entry>
                <entry>Accessor methods for the number of width sections to use when drawing the
                  cuboid.</entry>
              </row>
              <row>
                <entry>getHeightSections/setHeightSections</entry>
                <entry>Accessor methods for the number of height sections to use when drawing the
                  cuboid</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Sphere</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Sphere primitive draws a sphere on screen using triangles.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Sphere Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>radius</entry>
                <entry>The radius of the sphere </entry>
              </row>
              <row>
                <entry>detail</entry>
                <entry>The detail parameter controls the number of length and width sections.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Sphere Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getRadius/setRadius</entry>
                <entry>Accessor methods for the length of the sphere</entry>
              </row>
              <row>
                <entry>getDetail/setDetail</entry>
                <entry>Accessor methods for the width of the sphere</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Torus</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Torus primitive draws a torus on screen using triangles.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Torus Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>innerRadius</entry>
                <entry>The radius of the hole throught he middle of the torus </entry>
              </row>
              <row>
                <entry>outerRadius</entry>
                <entry>The radius of the body section of the torus</entry>
              </row>
              <row>
                <entry>detail</entry>
                <entry>The detail parameter controls the number of sections used to generate the
                  shape of the torus.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Torus Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getInnerRadius/setInnerRadius</entry>
                <entry>Accessor methods for the length of the torus</entry>
              </row>
              <row>
                <entry>getOuterRadius/setOuterRadius</entry>
                <entry>Accessor methods for the outer radius of the torus</entry>
              </row>
              <row>
                <entry>getDetail/setDetail</entry>
                <entry>Accessor methods for the detail paramerer of the torus</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Cone</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Torus primitive draws a torus on screen using triangles.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Torus Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>innerRadius</entry>
                <entry>The radius of the hole throught he middle of the Cone </entry>
              </row>
              <row>
                <entry>outerRadius</entry>
                <entry>The radius of the body section of the Cone</entry>
              </row>
              <row>
                <entry>detail</entry>
                <entry>The detail parameter controls the number of sections used to generate the
                  shape of the Cone.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Torus Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getInnerRadius/setInnerRadius</entry>
                <entry>Accessor methods for the length of the Cone</entry>
              </row>
              <row>
                <entry>getOuterRadius/setOuterRadius</entry>
                <entry>Accessor methods for the outer radius of the Cone</entry>
              </row>
              <row>
                <entry>getDetail/setDetail</entry>
                <entry>Accessor methods for the detail paramerer of the Cone</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Cylinder</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Cylinder primitive draws a cylinder on screen using triangles.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cylinder Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>radius</entry>
                <entry>The radius of the body of the Cylinder </entry>
              </row>
              <row>
                <entry>height</entry>
                <entry>The height of the body of the Cylinder</entry>
              </row>
              <row>
                <entry>caps</entry>
                <entry>Constrols whether the generated cylinder is capped at both ends.</entry>
              </row>
              <row>
                <entry>sides</entry>
                <entry>The number of sides to use when generating the cylinder.</entry>
              </row>
              <row>
                <entry>loops</entry>
                <entry>the number of loops to use when generating the cylinder.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Cylinder Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getRadius/setRadius</entry>
                <entry>Accessor methods for the radius of the Cylinder</entry>
              </row>
              <row>
                <entry>getHeight/setHeight</entry>
                <entry>Accessor methods for the height of the Cylinder</entry>
              </row>
              <row>
                <entry>getCaps/setCaps</entry>
                <entry>Accessor methods for the caps parameter of the Cylinder</entry>
              </row>
              <row>
                <entry>getSides/setSides</entry>
                <entry>Accessor methods for the number of sides of the Cylinder</entry>
              </row>
              <row>
                <entry>getLoops/setLoops</entry>
                <entry>Accessor methods for the number of loops of the Cylinder</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Teapot</title>
        <para>ParentNode: <emphasis role="bold">Triangles</emphasis></para>
        <para>The Teapot primitive draws the classic teapot primitive onscreen using
          triangles.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Teapot Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>size</entry>
                <entry>The size of the teapot primitive</entry>
              </row>
              <row>
                <entry>detail</entry>
                <entry>The detail parameter controls the number of sections used to generate the
                  shape of the Teapot.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Teapot Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="251.25pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getSize/setSize</entry>
                <entry>Accessor methods for the length of the Teapot</entry>
              </row>
              <row>
                <entry>getDetail/setDetail</entry>
                <entry>Accessor methods for the detail paramerer of the Teapot</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Cameras.js</title>
      <section>
        <title>Camera</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The base Camera node is used to control the viewpoint and projection used during
          rendering.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Camera Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>nearDistance</entry>
                <entry>The near clipping plane distance for the camera.</entry>
              </row>
              <row>
                <entry>farDistance</entry>
                <entry>The far clipping plane distance for the camera.</entry>
              </row>
              <row>
                <entry>fovY</entry>
                <entry>The vertical (Y) field of view angle for this camera. </entry>
              </row>
              <row>
                <entry>focalDistance</entry>
                <entry>The focal distance for the camera.</entry>
              </row>
              <row>
                <entry>orthographic</entry>
                <entry>Set to true the camera is rendered in orthographic more, otherwise
                  perspective mode is used.</entry>
              </row>
              <row>
                <entry>transformNode</entry>
                <entry>The transform node to use.</entry>
              </row>
              <row>
                <entry>screenOffset</entry>
                <entry>Viewport center offset</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Camera Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getNearDistance/setNearDistance</entry>
                <entry>Get/Set the near clipping plane distance.</entry>
              </row>
              <row>
                <entry>getFarDistance/setFarDistance</entry>
                <entry>Get/Set the far clipping plane distance.</entry>
              </row>
              <row>
                <entry>getFovY/setFovY</entry>
                <entry>Get/Set the vertical (Y) field of view angle. </entry>
              </row>
              <row>
                <entry>getFocalDistance/setFocalDistance</entry>
                <entry>Get/Set the focal distance. Note: the focal distance may be used in shaders
                  that perform lense effects. Also, the focal distance is computed in the
                  'TargetCamera' defined below.</entry>
              </row>
              <row>
                <entry>getOrthographic/setOrthographic</entry>
                <entry>Sets the given attribute to use Static OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </entry>
              </row>
              <row>
                <entry>getTransformNode/setTransformNode</entry>
                <entry>Get/Set the Transform node used by this camera.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>FreeCamera</title>
        <para>ParentNode: <emphasis role="bold">Camera</emphasis></para>
        <para>A free camera is transformed using a regular Transform node, rather than using a
          target position to align the camera. A free camera is usefull when setting up orthographic
          projections where you do not want the camera to alight ot any given target, but simpy
          maintain a given orientation. The Free camera exposes no extra methos, and simply
          configures a default transform node.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>FreeCamera Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>position</entry>
                <entry>The initial position of the camera.</entry>
              </row>
              <row>
                <entry>orientation</entry>
                <entry>the initial orientation of the camera.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>TargetCamera</title>
        <para>ParentNode: <emphasis role="bold">Camera</emphasis></para>
        <para>The TargetCamera uses the 'AimTransform' node to align itself with a given target. The
          TargetCamera uses the distance from the camera to the target to compute its focalDistance.
          Most of the demos in the Fabric demos page use Target Camera as it it</para>
      </section>
    </section>
    <section>
      <title>Images.js</title>
      <para>The nodes defined in the Images file are all retating to the storage of pixel data,
        either from loaded images, or generated on the GPU.</para>
      <section>
        <title>Image</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The base Image provides no functionality and is simply a parent type for all image
          types.</para>
      </section>
      <section>
        <title>RenderTargetBufferTexture</title>
        <para>ParentNode: <emphasis role="bold">Image</emphasis></para>
        <para>The RenderTargetBufferTexture is used to bind render target buffers to be used as
          textures. This Image type is used for planar reflections, where the scene is rendered to a
          buffer and then the buffer used as a texture on a reflective surface. It is also used in
          the Deffered Renderer to provide the buffered generated in the 'pre-pass' as textures to
          the 'post pass' shaders. </para>
        <table frame="none" colsep="0" rowsep="0">
          <title>RenderTargetBufferTexture Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>bufferIndex</entry>
                <entry>The index of the render target buffer to be bound as a texture. </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Image2D</title>
        <para>ParentNode: <emphasis role="bold">Image</emphasis></para>
        <para>The Image2D node is the basic texture storage node. The Image2D node holds generic
          image data (members: pixels, width, height), which might be color or grayscale. If
          'options.createResourceLoadNode' is passed in as true, an URL-based image loader will be
          incorporated, and used to load the pixel data. The Image2D node currently supports RGB,
          RGBA 8 bits per pixel images, and Color 32 bits per pixel images, and Scalar pixel
          formats.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>format</entry>
                <entry>Pixel format. Currently supported: RGB, RGBA, Color and Scalar.</entry>
              </row>
              <row>
                <entry>createDgNodes</entry>
                <entry>If this is set to true the Image node will construct a dgnode to store the
                  pixel data. The dgnode stores the data in multiple slices, one slice for each
                  pixel. This is usefull for when building applications that need to perform
                  per-pixel operations on the CPU. operators applied to the pixels dgnode operate in
                  a similar way to operators that operate on vertices of a geometry, being applied
                  to many pixels in parallel.</entry>
              </row>
              <row>
                <entry>createResourceLoadNode</entry>
                <entry>Set to true this flag will enable the Image node to load a texture off a
                  resource load node.</entry>
              </row>
              <row>
                <entry>createLoadTextureEventHandler</entry>
                <entry>If the image uses a ResouceLoadNode and this flag is set, it will create an
                  EventHandler for the Image being loaded.</entry>
              </row>
              <row>
                <entry>width</entry>
                <entry>The width of the empty Image</entry>
              </row>
              <row>
                <entry>height</entry>
                <entry>The height of the empty Image</entry>
              </row>
              <row>
                <entry>color</entry>
                <entry>When initializing an emply image, all the pixels are set to this
                  color</entry>
              </row>
              <row>
                <entry>url</entry>
                <entry/>
              </row>
              <row>
                <entry>forceRefresh</entry>
                <entry>If this is set, the Image will always be re-loaded onto the GPU. This is
                  useful for animated Images.</entry>
              </row>
              <row>
                <entry>glRepeat</entry>
                <entry>If set to true, the image is set to repeat in bot U and V directions.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getWidth</entry>
                <entry>Get the width of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</entry>
              </row>
              <row>
                <entry>getHeight</entry>
                <entry>Get the height of the stored texture. Note: this method is only available
                  when createDgNodes is set to true when constructing this node.</entry>
              </row>
              <row>
                <entry>getResourceLoadNode</entry>
                <entry>Get the resource load node used to load the image data.</entry>
              </row>
              <row>
                <entry>isImageLoaded</entry>
                <entry>Returns true once the image has finished loading.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Image3D</title>
        <para>ParentNode: <emphasis role="bold">Image</emphasis></para>
        <para>The Image3D node holds generic image data (members: pixels, width, height, depth),
          which might be color or grayscale. If  'options.createResourceLoadNode' is passed in as
          true, an URL-based image loader will be incorporated, and used to load the pixel data. The
          Image3D node currently supports RGBA 8 bits per pixel images, and Color 32 bits per pixel
          images. The Image3D node is used in the volume rendering demos to store the volumetric MRI
          data.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>format</entry>
                <entry>Pixel format. Currently supported: RGB, RGBA, Color and Scalar.</entry>
              </row>
              <row>
                <entry>createDgNodes</entry>
                <entry>If this is set to true the Image node will construct a dgnode to store the
                  pixel data. The dgnode stores the data in multiple slices, one slice for each
                  pixel. This is usefull for when building applications that need to perform
                  per-pixel operations on the CPU. operators applied to the pixels dgnode operate in
                  a similar way to operators that operate on vertices of a geometry, being applied
                  to many pixels in parallel.</entry>
              </row>
              <row>
                <entry>createResourceLoadNode</entry>
                <entry>Set to true this flag will enable the Image node to load a texture off a
                  resource load node.</entry>
              </row>
              <row>
                <entry>createLoadTextureEventHandler</entry>
                <entry>If the image uses a ResouceLoadNode and this flag is set, it will create an
                  EventHandler for the Image being loaded.</entry>
              </row>
              <row>
                <entry>width</entry>
                <entry>The width of the empty Image</entry>
              </row>
              <row>
                <entry>height</entry>
                <entry>The height of the empty Image</entry>
              </row>
              <row>
                <entry>depth</entry>
                <entry>The depth of the empty Image</entry>
              </row>
              <row>
                <entry>url</entry>
                <entry/>
              </row>
              <row>
                <entry>glRepeat</entry>
                <entry>If set to true, the image is set to repeat in bot U and V directions.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getWidth</entry>
                <entry>Get the width of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</entry>
              </row>
              <row>
                <entry>getHeight</entry>
                <entry>Get the height of the stored texture. Note: this method is only available
                  when createDgNodes is set to true when constructing this node.</entry>
              </row>
              <row>
                <entry>getDepth</entry>
                <entry>Get the depth of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</entry>
              </row>
              <row>
                <entry>getResourceLoadNode</entry>
                <entry>Get the resource load node used to load the image data.</entry>
              </row>
              <row>
                <entry>isImageLoaded</entry>
                <entry>Returns true once the image has finished loading.</entry>
              </row>
              <row>
                <entry>getUrl/setUrl</entry>
                <entry>interface to the URL used to load the pixel data for this image.</entry>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>CubeMap</title>
        <para>ParentNode: <emphasis role="bold">Image</emphasis></para>
        <para>The CubeMap node contains 6 Image nodes which can be used to texture with cubic
          mapping. The 6 sides of the cube are loaed as separate textures. Note: the CubeMap only
          supports 8 bits per pixel textures at this point.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>CubeMap Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>urls</entry>
                <entry>An array of six URLs to the six images to load.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Video</title>
        <para>ParentNode: <emphasis role="bold">Image</emphasis></para>
        <para>The CubeMap node contains 6 Image nodes which can be used to texture with cubic
          mapping. The 6 sides of the cube are loaed as separate textures. Note: the CubeMap only
          supports 8 bits per pixel textures at this point.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Video Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>url</entry>
                <entry>The url of the video to load.</entry>
              </row>
              <row>
                <entry>animationControllerNode</entry>
                <entry>The animation controller used to drive the playback of the video</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getAnimationController/setAnimationController</entry>
                <entry>Get or set the Animation Controller. Animation Controllers are used to
                  calculate the time values to be used in the video node. The animation controller
                  can be used to calculate a looping time sequence for example.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>ScreenGrab</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The ScreenGrab node is used to capture the rendered openGL viewport to an image file. </para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>saveAs</entry>
                <entry>Used to open a saveAs dialog box and write out the image as a PNG
                  file.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Materials.js</title>
      <para>The materials system in Fabric is built using OpenGL shader based rendering using GLSL
        shaders. </para>
      <section>
        <title>Shaders vs Materials</title>
        <para>The rendering system in Fabric is built around the depth first traversial of the event
          hander graph atached to the window redraw event. The redraw event graph represents a
          callstack, where at each event handler, the children are visited in order and executed. A
          parent nodes is always evaluated before a child node, and a parent node can have many
          children. The 'Shader' node is the parent of the 'Material' nodes attached to it. The
          Shader node is responsible for loading the GLSL shader code into the GPU, and setting the
          shader context. The Material node is responsible for setting shader parameters, such as
          setting color values, or binding textures. </para>
        <para>Changing the shader constex is a relatively expensive operation and should be
          minimized, and this is what drove the design of the rendering pipeline. For each shader,
          we load the shader and set the context, then for each Material, we set the parameters, and
          load appropriate textures. This graph structure enables batching of rendered objects
          acording to the Shader that they use, and also the Material parameters. This means that if
          you have many objects all drawn using the same shader and material parameters,they will be
          drawn together using only one shader binding. </para>
      </section>
      <section>
        <title>getShaderParamID</title>
        <para>The getShaderParamID function is used to generate unique identifier IDs for shader
          attribute and uniform names. For example, a shader might have a uniform named 'positions'.
          At graph construciton time, we convert the string 'positions' into a number so that we can
          match shader uniforms with data in the graph without doing many string comparisons each
          frame. At the time the rendering system was being developed, KL did not provide strong
          support for strings, however this has changed, and so this techniqure may be removed in
          future. </para>
      </section>
      <section>
        <title>Shader</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The Shader node is used to load a GLSL shader onto the GPU. Shader nodes are never
          constructed directly, and instead are constructed by the Material. Each type of Material
          shares a common shader node. The Scene maintains a map of constructed Shader nodes,
          ensuring that only one of each type is constructed. This means that for a given Material
          type, such as 'FlatTextureMaterial', even if many different instances of the materil are
          constructed using different textures, only one shader node is constructed, and loaded
          during rendering.</para>
      </section>
      <section>
        <title>Material</title>
        <para>ParentNode: <emphasis role="bold">SceneGraphNode</emphasis></para>
        <para>The Material node is the base node used to construct all types of Materials. The
          Material node uses many passed in options to define the material interface. The material
          system is driven using XML files.</para>
        <section>
          <title>Material XML File Structure</title>
          <para>The Material node is the base node used to construct all types of Materials. The
            Material node uses many passed in options to define the material interface. The material
            system is driven using XML files.</para>
          <db:para>The XML files define a mapping between GLSL shader code, and the naming
            conventions used in the SceneGraph. e.g. in your GLSL shader code you could use a
            variable called 'u_mvp', which contains your model view projeciton matix. In Fabric, the
            name this value is 'modelViewProjectionMatrix'. The XML file enables you to specify the
            mapping between your own variable names, and the naming convention used in Fabric. For
            variables that do not have a predefined meaning the the scenegraph, such as custom
            parameters for shaders, the XML file neables providing a user friendly name to be used
            to generate getters and setters for these paramers in JavaScript.</db:para>
          <db:para>XML files containing shaders can be used to define custom material nodes using
            the helper function:</db:para>
          <db:para><db:code>FABRIC.SceneGraph.defineEffectFromFile('MaterialName',
              'MaterialXMLFile.XML);</db:code></db:para>
          <db:para>The genrated node exposes and interface for assigning uniform values such as
            color and opacoity values, and also exposes an interface for assigning references such
            as textures and lights.</db:para>
          <section>
            <title>name</title>
            <para>The name parameter is currently not used. </para>
          </section>
          <section>
            <title>prototypeMaterialType</title>
            <para>The prototypeMaterialType parameter enables the specification of a base material
              node to derive this custom material from. There are a collection of base material
              types that provide custom functionality that custom materials can inherit from.</para>
          </section>
          <section>
            <title>uniforms</title>
            <para>The uniforms section defines the mapping between the uniforms used in the GLSL
              shader code, and the the interface exposed by the material. </para>
            <section>
              <title>name</title>
              <para>The  name value specifies the name used int he GLSL code. This name value can be
                different for each  shader, and will often be shortened or abbreviated names used in
                the glsl code.</para>
            </section>
            <section>
              <title>constant</title>
              <para>The constant value specifies the lable used in the SceneGraph. For example, if
                the constant name for the uniform 'u_materialColor' is specified as 'color', then a
                member called 'color' will be added to the material node, and a getter function
                called 'getColor', and a setter function called 'setColor' will be defined.</para>
            </section>
            <section>
              <title>type</title>
              <para>The type value specifies the Fabric registered type to use for this constant.
                All the GLSL types have corresponding Fabric types that are used when loading the
                uniform values. </para>
            </section>
            <section>
              <title>owner</title>
              <para>The owner value is optional. The owner attribute specifies that the Material
                should not generate a member and getter and setter funcions, because this uniform is
                loaded by the specified node. For example, when the owner is listed as 'instance',
                the instance will load that uniform, and the material should not provide loading
                functions.</para>
            </section>
          </section>
          <section>
            <title>attributes</title>
            <para>The attributes section defines the mapping between the attributes used in the GLSL
              shader code, and the vertex attributes stored in the geometry node. every shader uses
              the 'positions' attribute, but any custom vertex attributes can be listed, and if they
              exist on the geometry, they will be loaded prior to shader invocation.</para>
            <section>
              <title>name</title>
              <para>The  name value specifies the name used in the GLSL code. This name value can be
                different for each  shader, and will often be shortened or abbreviated names used in
                the glsl code.</para>
            </section>
            <section>
              <title>binding</title>
              <para>The binding value specifies the name of the member on the geometry's attribute
                node. For example, all triangles support 'positions', and 'normals' as attributes,
                but geometries can have any number of attributes assigned, and those attributes can
                be mapped to GLSL shader attributes using the binding value here.</para>
            </section>
          </section>
          <section>
            <title>programParams</title>
            <para>The programParams sections enables the definition of custom GLSL program
              parameters. Any OpenGL program params can be listed, and can be used, for example, to
              control tesselation, or geometry shader parameters. An example of a shader that uses
              custom program params, is the 'NormalShader' that uses the OpenGL 'Geometry Shader' to
              convert vertex positions and normals to lines to enable drawing of normals on screen. </para>
            <section>
              <title>name</title>
              <para>The  name value specifies the name of the OpenGL program param.</para>
            </section>
            <section>
              <title>value</title>
              <para>The value attribute specifies the value to set the specified OpenGL program
                param to.</para>
            </section>
          </section>
          <section>
            <title>drawParams</title>
            <para>The drawParams sections enables the definition of custom GLSL draw parameters that
              are to be set by the shader node. </para>
            <section>
              <title>drawMode</title>
              <para>The drawMode can be set to a custom draw method, instead of using the default fo
                the drawn geometry type.</para>
            </section>
            <section>
              <title>patchVertices</title>
              <para>The patchVertices value can be specified when using tesselation shaders to
                control how the patches are generated at the tesselation stage.</para>
            </section>
          </section>
          <section>
            <title>Shader Sources</title>
            <para>For a complete OpenGL shader to run, shader sources must be specified for each
              relevant shader stage. In the Shader sources of the XML file, source code can be
              specified for vertex, and fragment shaders, and also the more advanced shaders such as
              Geometry, and Tesselation shaders. </para>
            <section>
              <title>include</title>
              <para>Each of the various shader sources can include extra files. These included files
                are simply inlined and evaluated as part of the entire shader source.</para>
            </section>
            <section>
              <title>vertexshader</title>
              <para>The vertex shader sectionb lists GLSL vertex shader code. </para>
            </section>
            <section>
              <title>fragmentshader</title>
              <para>The fragment shader sectionb lists GLSL fragment, or pixel shader code. </para>
            </section>
          </section>
        </section>
      </section>
      <section>
        <title>ShadowMapMaterial</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The ShadowMapMaterial is a base material type that enables materials that are used in
          shadow map rendering to be derived from. The ShadowMapMaterial integrates the material
          into the drawing pipline at the point where shadow maps are being rendered from the lights
          point of view. The </para>
      </section>
      <section>
        <title>PointMaterial</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The PointMaterial extends the base Material with parameters for controlling the size
          of drawn points using the FixedFunction OpenGL calls. By specifying the PointMaterial as
          the 'PrototypeMaterial' in the shader XML file, shaders can extend this material type with
          custom drawing code.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>pointSize</entry>
                <entry>The default size value to be used to draw the points</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getPointSize/setPointSize</entry>
                <entry>Get and set the size values used to render the points.</entry>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>LineMaterial</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The LineMaterial extends the base Material with parameters for controlling the
          thickness of drawn lines using the FixedFunction OpenGL calls. By specifying the
          LineMaterial as the 'PrototypeMaterial' in the shader XML file, shaders can extend this
          material type with custom drawing code.</para>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Options</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="250pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>lineWidth</entry>
                <entry>The default thickness value to be used when drawing the lines</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="none" colsep="0" rowsep="0">
          <title>Image2D Methods</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="249pt"/>
            <colspec colnum="2" colname="c2" colwidth="400pt"/>
            <tbody>
              <row>
                <entry>getPointSize/setPointSize</entry>
                <entry>Get and set the size values used to render the points.</entry>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>TransparentMaterial</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The TransparentMaterial is a base material type that enables transparent materials to
          be integrated in the drawing pipeline. The TransparentMaterial integrates the material
          into the drawing pipline after all opaque materials have been drawn. </para>
      </section>
      <section>
        <title>InstancingMaterial</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The InstancingMaterial is a base material type that is used when drawing multiple
          instances of the same geometry. The InstancingMaterial sets the paramter on the shader
          program called numInstances. The InstancingMaterial is used in conjunction with
          TransformTexture. The Texture is used to load an array of model matricies, and the
          Materials tells the shader how many insances to draw.</para>
      </section>
      <section>
        <title>PostProcessEffect</title>
        <para>ParentNode: <emphasis role="bold">Material</emphasis></para>
        <para>The PostProcessEffect is a base material type for post processing effect Material
          nodes. The PostProcessEffect is attached to the Viewport, and is bound before any of the
          scenes geometry is rendered. The PostProcessEffect material sets up an Frame Buffer Object
          and binds it during rendering before rendering traverses to the geometries. On the post
          descend operator stack, it unbinds the FBO, and binds it as a texture for the shader. A
          full screen quad is then rendered using the shader. There are several example post
          processing effect shaders provided that show how the post processing effect integrates
          with the render pipeline.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Fabric Engine Extension Guides</title>
    <para>Extensions are additions to Fabric Engine's Kernel Language called KL and provide
      additional functions and types. Each extension is packaged for a particular use-case, for
      example the Alembic extension deals with Alembic files. Extensions can be implemented using
      Fabric Engine's EDK (Extension Developer Kit).</para>
    <section>
      <title>Alembic Extension Guide</title>
      <para>This extension adds a new type to KL, called the <emphasis role="italic"
          >AlembicHandle</emphasis>. It is used to load Alembic.IO files. The AlembicHandle
        represents a file handle to an Alembic file, and can be used to gather data.<table
          frame="none" colsep="0" rowsep="0">
          <title>AlembicHandle</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="349pt"/>
            <colspec colnum="2" colname="c2" colwidth="300pt"/>
            <tbody>
              <row>
                <entry><emphasis role="bold">Members</emphasis></entry>
                <entry/>
              </row>
              <row>
                <entry><emphasis role="italic">Data pointer</emphasis></entry>
                <entry>The private data of the handle.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">Vec2 timeRange</emphasis></entry>
                <entry>The min and max time of the Alembic file</entry>
              </row>
              <row>
                <entry><emphasis role="bold">Methods</emphasis></entry>
                <entry/>
              </row>
              <row>
                <entry><emphasis role="italic">loadResource(io FabricResource
                  resource)</emphasis></entry>
                <entry>Loads the content of a FabricResource onto the AlembicHandle if it doesn't
                  contain any content yet</entry>
              </row>
              <row>
                <entry><emphasis role="italic">loadFileHandle(io String
                  fileHandle)</emphasis></entry>
                <entry>Loads the Alembic file from a given FileHandle</entry>
              </row>
              <row>
                <entry><emphasis role="italic">getIdentifiers(io String
                  identifiers[])</emphasis></entry>
                <entry>Loads all of the identifiers of the Alembic file. This can be used to
                  determine how many and what kind of objects are stored in the Alembic
                  file.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parseXform(io String identifier, io Scalar time, io
                    Xfo transform)</emphasis></entry>
                <entry>Parses a Xform Alembic node at a given time and returns the Fabric Engine
                  Xfo.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parseCamera(io String identifier, io Scalar time, io
                    Scalar near, io Scalar far, io Scalar fovY)</emphasis></entry>
                <entry>Parses a Camera Alembic node at a given time and returns near and far
                  clipping, as well as vertical field of view.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parsePolyMeshCount(io String identifier, io Size
                    count)</emphasis></entry>
                <entry>Parses a PolyMesh Alembic node and returns the number of vertices of that
                  mesh.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parsePolyMeshUniforms(io String identifier, io
                    Integer indices[])</emphasis></entry>
                <entry>Parses a PolyMesh Alembic node and returns the face indices as a triangles
                  list.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parsePolyMeshAttributes(io String identifier, io
                    Scalar time, io Vec3 vertices&lt;>, io Vec3 normals&lt;>, io Boolean uvsLoaded,
                    io Vec2 uvs&lt;>)</emphasis></entry>
                <entry>Parses a PolyMesh Alembic node at a given time and returns the mesh's
                  vertices, normals, and optionally, uvs. All arrays are per vertex data.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parsePointsCount(io String identifier, io Scalar
                    time, io Size count)</emphasis></entry>
                <entry>Parses a Points Alembic node at a given time and returns its point
                  count</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parsePointsAttributes(io String identifier, io Scalar
                    time, io Vec3 positions&lt;>, io Quat orientations&lt;>, io Scalar sizes&lt;>,
                    io Vec3 scales&lt;>, io Color colors&lt;>)</emphasis></entry>
                <entry>Parses a Points Alembic node at a given time and returns its positions,
                  orientations, sizes, scales and colors. All arrays are per vertex data.</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parseCurvesCount(io String identifier, io Size
                    count)</emphasis></entry>
                <entry>Parses a Curves Alembic node at a given time and returns its vertex
                  count</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parseCurvesUniforms(io String identifier, io Integer
                    indices[])</emphasis></entry>
                <entry>Parses a Curves Alembic node and returns its line indices (as a from-to index
                  list)</entry>
              </row>
              <row>
                <entry><emphasis role="italic">parseCurvesAttributes(io String identifier, io Scalar
                    time, io Vec3 vertices&lt;>, io Scalar sizes&lt;>, io Boolean uvsLoaded, io Vec2
                    uvs&lt;>, io Color colors&lt;>)</emphasis></entry>
                <entry>Parses a Curves Alembic node at a given time and returns its vertices, sizes,
                  uvs and colors. All arrays are per vertex data.</entry>
              </row>
              <row>
                <entry/>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
    <section>
      <title>Bullet Extension Guide</title>
      <para>The Bullet Physics extension adds support for physics simulation in KL. It implements
        all of the core Bullet types, and allows perform raycasting into the bullet scene. For
        additional information please refer to the Bullet Physics Wiki
        (http://bulletphysics.org/mediawiki-1.5.8/index.php/Main_Page)</para>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletWorld</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 gravity</emphasis></entry>
              <entry>The gravity applied during the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Size step</emphasis></entry>
              <entry>The current simulation step of the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Size substeps</emphasis></entry>
              <entry>The number of substeps to perform per simulation step.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean hit</emphasis></entry>
              <entry>Indicates, after a raycast has been performed, if there is any hit
                object.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io Boolean success)</emphasis></entry>
              <entry>Creates the simulation world and returns if successful.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">step(io Scalar timeStep)</emphasis></entry>
              <entry>Steps through the simulation for a provided timeStep in seconds.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">reset()</emphasis></entry>
              <entry>Resets the simulation world by moving all rigid and soft bodies to their
                initial state and setting the simulation's step to 0.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">raycast(io Vec3 from, io Vec3 to, io Boolean
                  filterPassiveObjects, io BulletContact contacts[])</emphasis></entry>
              <entry>Performs a raycast into the simulation world and returns the hit
                contacts.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">applyForce(io BulletForce force)</emphasis></entry>
              <entry>Applies a force to the simulation at the current simulation step.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">getGravity(io Vec3 gravity)</emphasis></entry>
              <entry>Returns the current gravity of the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">setGravity(io Vec3 gravity)</emphasis></entry>
              <entry>Sets the gravity of the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">addRigidBody(io BulletRigidBody
                body)</emphasis></entry>
              <entry>Adds a rigid body to the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">removeRigidBody(io BulletRigidBody
                body)</emphasis></entry>
              <entry>Removes a rigid body from the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">addSoftBody(io BulletSoftBody body)</emphasis></entry>
              <entry>Adds a soft body to the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">removeSoftBody(io BulletSoftBody
                body)</emphasis></entry>
              <entry>Removes a soft body from the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">addConstraint(io BulletConstraint
                  constraint)</emphasis></entry>
              <entry>Adds a constraint to the simulation.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">removeConstraint(io BulletConstraint
                  constraint)</emphasis></entry>
              <entry>Removes a constraint from the simulation.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletShape</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer type</emphasis></entry>
              <entry>The type of the shape. The Bullet extension also provides constants for this
                type. The valid values are: BULLET_BOX_SHAPE, BULLET_CONVEX_HULL_SHAPE,
                BULLET_SPHERE_SHAPE, BULLET_CAPSULE_SHAPE, BULLET_CONE_SHAPE, BULLET_CYLINDER_SHAPE,
                BULLET_TRIANGLEMESH_SHAPE, BULLET_GIMPACT_SHAPE, BULLET_PLANE_SHAPE and
                BULLET_COMPOUND_SHAPE.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the shape. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar parameters[]</emphasis></entry>
              <entry>The parameter for the shape creation. The number of parameters varies for each
                shape. To determine which parameters should be used create a shape without
                parameters and read the thrown exception.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 vertices[]</emphasis></entry>
              <entry>For convex hull, gimpact or triangle mesh this stores the vertices of the
                shape. For all other shape types it isn't used.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer indices[]</emphasis></entry>
              <entry>For gimpact or triangle mesh shapes this stores the triangle indices of the
                shape. For all other shape types it isn't used.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io Boolean success)</emphasis></entry>
              <entry>Creates the shape and returns if successful.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletRigidBody</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the rigid body. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Xfo transform</emphasis></entry>
              <entry>The initial transform.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar mass</emphasis></entry>
              <entry>The mass in kilograms. A mass of 0.0 indicates a passive, non-simulated rigid
                body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar friction</emphasis></entry>
              <entry>The combined dynamic and static friciton (0.0 to 1.0).</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar restitution</emphasis></entry>
              <entry>The restitution factor, from 0.0 to 1.0</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io BulletShape shape, io Boolean
                  success)</emphasis></entry>
              <entry>Creates the rigid body based on its member data and the provided shape, returns
                if successful.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">setMass(in Scalar mass)</emphasis></entry>
              <entry>Sets the mass</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Xfo getTransform()</emphasis></entry>
              <entry>Returns the current simulated transform.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">setTransform(in Xfo transform)</emphasis></entry>
              <entry>Sets the transform. This only works for passive rigid bodies (mass of
                0.0)</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 getLinearVelocity()</emphasis></entry>
              <entry>Returns the current linear velocity</entry>
            </row>
            <row>
              <entry><emphasis role="italic">setLinearVelocity(in Vec3 velocity)</emphasis></entry>
              <entry>Sets the linear velocity</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 getAngularVelocity()</emphasis></entry>
              <entry>Returns the angular velocity (as euler angles in radians)</entry>
            </row>
            <row>
              <entry><emphasis role="italic">setAngularVelocity(in Vec3 velocity)</emphasis></entry>
              <entry>Sets the angular velocity (from euler angles in radians)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletSoftBody</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the soft body. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Xfo transform</emphasis></entry>
              <entry>The initial transform.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer clusters</emphasis></entry>
              <entry>The cluster count to use for this softbody. When set to zero, the cluster
                collision algorithm won't be used, and a per vertex spring model will be
                used.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer constraints</emphasis></entry>
              <entry>The recursion depth level for bending constraints. Set to 1 there will be a
                spring between each neighbor vertex, set to 2 introduces springs between neighbors
                of neighbors etc.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar mass</emphasis></entry>
              <entry>The mass of the softbody in kilograms.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar stiffness</emphasis></entry>
              <entry>The linear stiffness factor for the springs (0.0 to 1.0)</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar friction</emphasis></entry>
              <entry>The dynamic friction of each softbody vertex (0.0 to 1.0)</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar conservation</emphasis></entry>
              <entry>The volume conservation of the softbody (0.0 to 1.0). This is a very sensitive
                parameter and use of values higher than 0.1 is not recommended.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar pressure</emphasis></entry>
              <entry>The internal pressure of the soft body in nm.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar recover</emphasis></entry>
              <entry>The amount of shape recovery (0.0 to 1.0). If set to 0.5, for example, the
                shape is blended back to its original shape by 50%.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io Boolean success, io BulletWorld world, io
                  Vec3 positions&lt;>, io Vec3 normals&lt;>, io Integer
                indices[])</emphasis></entry>
              <entry>Creates the softbody in a provided simulation world, using the provided
                positions, normals and indices arrays (triangles). Returns if successful.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">getPosition(in Size index, io Vec3 position, io Vec3
                  normal)</emphasis></entry>
              <entry>Returns the current position and normal for a given vertex index.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletConstraint</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Data bodyLocalDataA</emphasis></entry>
              <entry>The pointer to the private data of the first attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Data bodyLocalDataB</emphasis></entry>
              <entry>The pointer to the private data of the second attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer type</emphasis></entry>
              <entry>The type of the constraint. Valid values are 3 (point2point), 4 (hinge) and 7
                (slider).</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the constraint. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Xfo pivotA</emphasis></entry>
              <entry>The pivot transform in local space for the first attached rigid body</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Xfo pivotB</emphasis></entry>
              <entry>The pivot transform in local space for the second attached rigid body</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String nameA</emphasis></entry>
              <entry>The name of the first attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String nameB</emphasis></entry>
              <entry>The name of the second attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer indexA</emphasis></entry>
              <entry>The index of the first attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer indexB</emphasis></entry>
              <entry>The index of the second attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar parameters[]</emphasis></entry>
              <entry>The parameters for the constraint creation. This member is obsolete and is not
                being used.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io Boolean result, io BulletRigidBody bodiesA[],
                  io BulletRigidBody bodiesB[])</emphasis></entry>
              <entry>Creates the constraing based on its <emphasis role="italic">indexA</emphasis>
                and <emphasis role="italic">indexB</emphasis> members. The private data pointers are
                set by retreiving them from A and B rigid body arrays. This allows to construct a
                large number of constraints on lists of rigid bodies.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletForce</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the force. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 origin</emphasis></entry>
              <entry>The point the force is coming from (global space).</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 direction</emphasis></entry>
              <entry>The direction of the force (global space)</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar radius</emphasis></entry>
              <entry>The influence radius of the force</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar factor</emphasis></entry>
              <entry>The force factor in nm.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean useTorque</emphasis></entry>
              <entry>Determines if the force should apply rotation or only linear velocity.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean useFalloff</emphasis></entry>
              <entry>If set the force will use a linear falloff inside its radius.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean enabled</emphasis></entry>
              <entry>If set to false the force will be ignored</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean autoDisable</emphasis></entry>
              <entry>If set to true the force's <emphasis role="italic">enabled</emphasis> flag will
                be set once it is applied. This is useful for one-shot forces, based on mouse
                clicks, for example.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletAnchor</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data localData</emphasis></entry>
              <entry>The private data of the Bullet type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Data rigidBodyLocalData</emphasis></entry>
              <entry>The pointer to the private data of the attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Data softBodyLocalData</emphasis></entry>
              <entry>The pointer to the private data of the attached soft body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String name</emphasis></entry>
              <entry>The name of the anchor. Names have to be unique.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer rigidBodyIndex</emphasis></entry>
              <entry>The index of the attached rigid body.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Integer softBodyNodeIndices[]</emphasis></entry>
              <entry>The indices of the attached vertices of the soft body mesh.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean disableCollision</emphasis></entry>
              <entry>Determines if the rigid body and soft body attached to the anchor should
                intercollide.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">create(io Boolean success, io BulletRigidBody
                  rigidBodies[], io BulletSoftBody softBody)</emphasis></entry>
              <entry>Creates the constraing based on its <emphasis role="italic"
                  >rigidBodyIndex</emphasis>. The private data pointers are set by retreiving them
                from the rigid body array resp. the provided soft body. This allows to construct a
                large number of anchors on a list of rigid bodies. Returns if successful.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table frame="none" colsep="0" rowsep="0">
        <title>BulletContact</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar fraction</emphasis></entry>
              <entry>The fraction of the ray</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 normal</emphasis></entry>
              <entry>The normal of the hit surface position</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar mass</emphasis></entry>
              <entry>The mass of the collision object's surface position.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 linearVelocity</emphasis></entry>
              <entry>The linear velocity of the collision object.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Vec3 angularVelocity</emphasis></entry>
              <entry>The angular velocity of the collision object (euler angles in radians).</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>CIMG Extension Guide</title>
      <para>The CIMG extension wraps the CIMG C++ image library (http://cimg.sourceforge.net) and
        provides read and write access to image within Fabric Engine. The extension doesn't provide
        any types, but KL functions to perform the image IO.</para>
      <table frame="none" colsep="0" rowsep="0">
        <title>CIMG Functions</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="italic">FabricCIMGDecode( Data data, Size dataSize, io String
                  ext, io Size imageWidth, io Size imageHeight, io RGBA imagePixels[]
                )</emphasis></entry>
              <entry>Decodes an image, stored as an encoded Byte array into its width, height and
                pixel values. The extention has to be provided to inform CIMG what kind of image is
                stored in the Byte array.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">FabricCIMGOpenFileHandle( String fileHandle, io String
                  ext, io Size imageWidth, io Size imageHeight, io RGBA imagePixels[]
                )</emphasis></entry>
              <entry>Opens an image from a provided FileHandle and reads the image data into the
                width, height and pixel values. The extention has to be provided to inform CIMG what
                kind of image is stored in the FileHandle.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">FabricCIMGCreateFromText( String text, io Size
                  imageWidth, io Size imageHeight, io RGBA imagePixels[] ) </emphasis></entry>
              <entry>Encodes the text provided into a new image resulting in width, height and pixel
                values. The image uses a fixed text size and is stored as black and white, where
                white is the text and black is the background.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">FabricCIMGSaveToFileHandle( String fileHandle, Size
                  imageWidth, Size imageHeight, Boolean mirrorVertically, io RGBA imagePixels[]
                  )</emphasis></entry>
              <entry>Saves a provided image, represented by with, height and pixels into a provided
                writable FileHandle. If required, the image can be flipped vertically prior to
                saving.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>LIDAR Extension Guide</title>
      <para>The LIDAR extension is a wrapper for the liblas library (http://liblas.org/). It
        provides a type to read the contents of a LIDAR file and use it inside Fabric Engine.</para>
      <table frame="none" colsep="0" rowsep="0">
        <title>LidarReader</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="bold">Members</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">Data pointer</emphasis></entry>
              <entry>The private data of the LidarReader type.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">String url</emphasis></entry>
              <entry>The url of the parsed lidar file.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Boolean compressed</emphasis></entry>
              <entry>After the file is opened this will indicate if it is a compressed file or
                not.</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Methods</emphasis></entry>
              <entry/>
            </row>
            <row>
              <entry><emphasis role="italic">loadResource(io FabricResource resource, io String
                  url)</emphasis></entry>
              <entry>Loads a lidar file stored in memory. The url value is not used in this case,
                and is just cosmetic.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">loadFileHandle(in String handle)</emphasis></entry>
              <entry>Loads a lidar file stored in a readable FIleHandle.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">getCount(io Size count)</emphasis></entry>
              <entry>Returs the number of points in the lidar file.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">getPoints(io Vec3 positions&lt;>, io Color
                  colors&lt;>)</emphasis></entry>
              <entry>Returns all of the point positions and colors inside the lidar file. If the
                lidar file doesn't contain any colors, they will be all black.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>Math Extension Guide</title>
      <para>The Math extension provides additional Math features to KL. Currently it only contains a
        pseudo random number generator.</para>
      <table frame="none" colsep="0" rowsep="0">
        <title>Math Functions</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="c1" colwidth="349pt"/>
          <colspec colnum="2" colname="c2" colwidth="300pt"/>
          <tbody>
            <row>
              <entry><emphasis role="italic">Integer mathRandomInteger( in Size id, in Size offset
                  )</emphasis></entry>
              <entry>Returns the random integer number id with a provided random offset. The offset
                can be understood as the seed, while the id is the index of the random number in the
                sequence. The range is the full integer range.</entry>
            </row>
            <row>
              <entry><emphasis role="italic">Scalar mathRandomScalar( in Size id, in Size offset
                  )</emphasis></entry>
              <entry>Returns the random scalar number id with a provided random offset. The offset
                can be understood as the seed, while the id is the index of the random number in the
                sequence. The range is the full scalar range.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
</article>
