<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<!DOCTYPE book [
<!ENTITY % allent SYSTEM "w3centities-f.ent">
%allent;
]>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>KL Programming Guide</title>
    <copyright>
      <year>2011-2012</year>
      <holder>Fabric Engine Inc.</holder>
    </copyright>
  </info>
  
  <chapter>
    <title>Introduction</title>

    <para>
      KL (pronounced <emphasis>kale</emphasis>) is the programming language used for Fabric operators.  KL stands for <quote>kernel language</quote>; in this context, <emphasis>kernel</emphasis> refers to the concept of a computational kernel as used in multithreaded programming.
    </para>

    <para>
      KL was designed with the following goals:

      <itemizedlist>
        <listitem><para>
          KL is designed to run <glossterm>performance-critical</glossterm> sections of <glossterm>dynamic-language</glossterm> programs.  As such, KL is designed so that KL programs run as quickly as possible on modern hardware.
        </para></listitem>
        
        <listitem><para>
          KL should be easy to learn for someone who is already familiar with programming in JavaScript.
        </para></listitem>

        <listitem><para>
          It must be possible to compile most KL programs to run on different architectures and kinds of hardware, specifically <acronym>CPU</acronym>s and <acronym>GPU</acronym>s.
        </para></listitem>
      </itemizedlist>

      As such, KL is a language with a syntax very similar to JavaScript but which is <emphasis>procedural</emphasis>, <emphasis>strongly-typed</emphasis> and with <emphasis>low-level data layouts</emphasis>.  Being <emphasis>procedural</emphasis> means that, unlike JavaScript, functions (or, rather, closures) are not first-class objets that can be passed around in the language; instead, functions are always globally declared.  Being <emphasis>strongly-typed</emphasis> means that, in a KL program, the types of all variables and function parameters is known at compile type, unlike JavaScript where types are only known at runtime.  Having <emphasis>low-level data layouts</emphasis> means that the size of data and the way that it is laid out in memory is guaranteed and controllable by the programmer.
    </para>
    
    <para>
      Before diving in to the details of the language, we will present some simple examples.  We don't expect you to understand all the details of the examples, but hopefully they will give you a basic idea of what KL programs look like as well as some of what is possible with KL.  All of these examples can be run by downloading and installing the <filename>FabricEngine-KLTool-...</filename> file that is appropriate for your operating system from <link xlink:href="http://dist.fabric-engine.com/latest/">http://dist.fabric-engine.com/latest/</link>.  Once installed, you can copy the source code to a text file and run <command>kl <replaceable>filename.kl</replaceable></command>.
    </para>
    
    <section>
      <title>Hello World in KL</title>
      
      <para>
        Traditionally, the first program you see in a language is one that says hello.  In KL, the "Hello, world!" program is simple:
        
        <example xml:id="ex.helloworld.code">
          <title>Hello world</title>
          <programlisting language="KL"><![CDATA[
operator entry() {
  report("Hello, world!");
}
          ]]></programlisting>
        </example>
        
        Running this program through the <command>kl</command> tool, the output is:
      
        <informalfigure>
          <screen><![CDATA[
operator entry() {
  report("Hello, world!");
}
          ]]></screen>
        </informalfigure>
        
        There's not much to learn from this program, but it does introduce a few concepts:
        
        <itemizedlist>
          <listitem><para>The <code>entry</code> operator is what is run by the <command>kl</command> tool.  KL distinguishes places in the program that can be called from the outside world&mdash;in this case, the outside world is the <command>kl</command> tool itself.  We discuss more about operators <xref linkend="operators" /></para></listitem>
          <listitem><para>The <code>report</code> function sends some text to wherever messages go.  In the case of the <command>kl</command> tool, messages go to standard output; when running within a web browser, messages appear on the JavaScript console.</para></listitem>
          <listitem><para>The text <code>"Hello, world!"</code> is a <glossterm>string constant</glossterm>.  String constants in KL follow almost exactly the same syntax as JavaScript.</para></listitem>
        </itemizedlist>
      </para>
    </section>
      
    <section>
      <title>Fibonacci Sequence in KL</title>

      <para>
        Next, we present a somewhat more sophisticated example that computes the first few terms of the Fibonacci sequence.  The Fibonacci sequence is the number sequence whose first few terms are 1 and 1, and whose further terms are the sum of the previous two in the sequence, ie. 2, 3, 5, 8, and so on.  There are several ways of computing the Fibonacci sequence in a programming language but we choose the naive, recursive way in order to illustrate some more language features of KL.

        <example xml:id="ex.fibonacci.code">
          <title>Fibonacci sequence generator</title>
          <programlisting language="KL"><![CDATA[
/* Recursively compute the Fibonacci sequence.
** The first term is returned with n = 0
*/
function Integer fibonacci(Integer n) {
  if (n <= 1)
    return 1; // The first two terms (n=0 or n=1) are 1
  else 
    return fibonacci(n - 2) + fibonacci(n - 1);
}

operator entry() {
  for (Integer i = 0; i < 10; ++i)
    report(fibonacci(i));
}
          ]]></programlisting>
        </example>
        
        Running this program through the <command>kl</command> tool, the output is:
      
        <informalfigure xml:id="fig.fibonacci.out">
          <screen><![CDATA[
1
1
2
3
5
8
13
21
34
55
          ]]></screen>
        </informalfigure>
      
        The Fibonacci example highlights a few simple features of KL, including:

        <itemizedlist>
          <listitem><para>Function and parameter declaration</para></listitem>
          <listitem><para>Recursion</para></listitem>
          <listitem><para>Conditional statements</para></listitem>
          <listitem><para>Loops</para></listitem>
          <listitem><para>Comments</para></listitem>
        </itemizedlist>
      </para>
    </section>
    
    <section>
      <title>Mandelbrot Set in KL</title>
      
      <para>
        Finally, we present an example of a KL program that generates the Mandelbrot set and outputs it visually as ASCII art.  The Mandelbrot set is a mathematical set defined by complex recursive functions, but that it best known because the patterns it contains are visually stunning.  Refer to the Wikipedia entry on the Mandelbrot set at <link xlink:href="http://en.wikipedia.org/wiki/Mandelbrot_set">http://en.wikipedia.org/wiki/Mandelbrot_set</link> for more information.
      </para>
      
      <para>
        KL includes very powerful features for extending the language for computational problems such as that of computing the values of the Mandelbrot set, as seen in the source code below:
        
        <example xml:id="ex.mandelbrot.code">
          <title>Mandelbrot set generator</title>
          <programlisting language="KL"><![CDATA[
struct Complex32 {
  Float32 re;
  Float32 im;
};

function Complex32(Float32 re, Float32 im) {
  this.re = re;
  this.im = im;
}

function Complex32 +(Complex32 lhs, Complex32 rhs) {
  return Complex32(lhs.re + rhs.re, lhs.im + rhs.im);
}

function Complex32 *(Complex32 lhs, Complex32 rhs) {
  return Complex32(lhs.re*rhs.re-lhs.im*rhs.im, lhs.re*rhs.im + lhs.im*rhs.re);
}

function Float32 Complex32.normSq() {
  return this.re*this.re + this.im*this.im;
}

function Byte computeDwell(Complex32 c) {
  Complex32 z = c;
  Size count;
  for (count = 0; count < 255; ++count) {
    if (z.normSq > 4)
      break;
    z = z*z + c;
  }
  return count;
}

operator entry()
{
  Complex32 z;
  for (Size row=9; row<=31; ++row) {
    z.im = 4.0 * row / 40.0 - 2.0;
    String rowString;
    for (Size col=0; col<=78; ++col) {
      z.re = 4.0 * col / 78.0 - 2.0;
      Byte dwell = computeDwell(z);
      
      if (dwell & 192)
        rowString += "#";
      else if (dwell & 48)
        rowString += "*";
      else if (dwell & 12)
        rowString += ".";
      else
        rowString += " ";
    }
    report(rowString);
  }
}
          ]]></programlisting>
        </example>
        
        Running this program through the <command>kl</command> tool, the output is:
      
        <informalfigure xml:id="fig.mandelbrot.out">
          <screen><![CDATA[
                                  .....                                        
                                .......#.                                      
                              ......**.....                                    
                            .......####*.....                                  
                         ..........####.........                               
                    ........*#**##########*...*..                              
               .............*#################....                             
            ...............###################....                             
          ......*..*.*...*#####################...                             
        ........*######*.######################*..                             
      ......*..################################...                             
############################################*.....                             
      ......*..################################...                             
        ........*######*.######################*..                             
          ......*..*.*...*#####################...                             
            ...............###################....                             
               .............*#################....                             
                    ........*#**##########*...*..                              
                         ..........####.........                               
                            .......####*.....                                  
                              ......**.....                                    
                                .......#.                                      
                                  .....                                        
          ]]></screen>
        </informalfigure>
      
        The Mandelbrot set example highlights a few of the more sophisticated features of KL, including:

        <itemizedlist>
          <listitem><para>User-defined types</para></listitem>
          <listitem><para>Constructors</para></listitem>
          <listitem><para>Operator overloads</para></listitem>
          <listitem><para>Methods</para></listitem>
          <listitem><para>Bitwise operators</para></listitem>
          <listitem><para>Variable-length arrays</para></listitem>
        </itemizedlist>
      </para>
    </section>
    
    <section>
      <title>How This Guide is Organized</title>
      
      <para>
        Unlike other languages, KL is a language designed to add performance-critical sections to programs written in dynamic languages.  As such, this guide assumes that you are already familiar with the basic concepts of modern programming languages, including types, expressions, statements (eg. conditional statements, loop statements, return statements) and functions.
      </para>
      
      <para>
        Since it's difficult to provide meaningful examples in a computer language without using many concepts of the language, we will often use or even refer to concepts that aren't discussed until later in the guide.  We leave it up to you to decide whether to jump ahead or to just keep reading and see where things go.
      </para>
        
      <para>
        The remainder of the guide is laid out as follows:
        
        <itemizedlist>
          <listitem><para>
            <xref linkend="ch.syntax" /> describes the syntax of KL.  KL has a syntax very similar to JavaScript (like JavaScript, it is a <quote>C-like</quote> language) so this syntax will be familiar to many programmers.
          </para></listitem>
          
          <listitem><para>
            <xref linkend="ch.types" /> introduces the type system of KL.  KL comes with a rich set of base types that includes integers, floating-point numbers, strings and booleans, as well as derived types including structures, arrays and dictionaries.
          </para></listitem>
          
          <listitem><para>
            <xref linkend="ch.functions" /> describes how functions are declared and called in KL.  KL includes support for basic functions (also referred to as procedures in other languages), but also support more complex function concepts such as prototypes, methods and overloaded operators.
          </para></listitem>
        </itemizedlist>
      </para>
    </section>
  </chapter>
  
  <chapter xml:id="ch.syntax">
    <title>KL Syntax</title>
    
    <para>
      When KL was developed it was designed to have a syntax as close as possible to JavaScript, which itself is what is referred to as a <quote>C-like language</quote> (as far as syntax is concerned).  Some of the key characteristics of C-like languages are:
      
      <itemizedlist>
        <listitem><para>
          Programs are plain, human-readable text files.
        </para></listitem>
        
        <listitem><para>
          A program is a sequence of <glossterm>tokens</glossterm>.  There are four major types of tokens: keywords, identifiers, symbols and constants.
        </para></listitem>
        
        <listitem><para>
          Tokens may be separated by arbitrary whitespace and <emphasis>must</emphasis> be separated by whitespace in the case that it would make two adjacent tokens appear to be a single, different token.  By whitespace, we mean spaces (ASCII 32), newlines (ASCII 10), tabs (ASCII 9), carriage returns (ASCII 13) and vertical tabs (ASCII 11).
        </para></listitem>
        
        <listitem><para>
          Programs can contain comments anywhere and comments are treated like whitespace when the program is processed by the computer.  There are two types of comments: block comments, which begin with <code>/*</code> and end with <code>*/</code>, and line comments, which begin with <code>//</code> and continue to the next newline (ASCII 10).
        </para></listitem>
        
        <listitem><para>
          Blocks are delimited by <code>{</code> and <code>}</code>
        </para></listitem>
        
        <listitem><para>
          Statements are terminated with <code>;</code>
        </para></listitem>
      </itemizedlist>
      
      We delve into some more details of the KL syntax below.
    </para>
    
    <section>
      <title>Encoding</title>
      
      <para>
        Although KL programs are plain, human-readable text files, KL does specify an encoding for the text files: UTF-8.  The KL compiler assumes that all KL source code is encoded as UTF-8 without any encoding marks.  KL programs which contain invalid UTF-8 sequences cannot be compiled and will result in syntax errors.
      </para>
      
      <para>
        If you don't understand exactly what this means, don't worry: plain 7-bit ASCII text files, such as used for C source code (and often for JavaScript source code) are by default UTF-8 encoded.  The only thing to keep in mind is that text files saved on Windows in <quote>Unicode format</quote> (which technically means they are encoded as UCS-2) cannot be read by the KL compiler.  If you want to insert foreign language characters into a KL source file you must use an editor that can write UTF-8 files.
      </para>
      
      <para>
        The benefit of specifying an encoding is that high-bit characters, such as foreign language characters, can be inserted directly into string constants in KL source files.
      </para>
    </section>
    
    <section>
      <title>Comments</title>
      
      <para>
        As mentioned previously, KL supports the same two types of comments as C and JavaScript: block comments and line comments.
      </para>
        
      <section>
        <title>Block Comments</title>
        
        <para>
          A block comment in KL is an arbitrary sequence of characters that begins with the characters <code>/*</code> and ends with the characters <code>*/</code>.  Like C, KL ends a block comment as soon as it encounters the first sequence <code>*/</code>.  Also like C, KL does not recognize nested comments.  The following examples illustrate acceptable and erroneous bad block comments in KL.
        </para>
        
        <example>
          <title>Acceptable block comments</title>
          <programlisting language="KL"><![CDATA[
/* A simple, one-line block comment */

/* This is
   a multi-line
   block comment
   */
   
/*
** And so is this
*/

operator entry() {
  /* comment can appear in source code
  report("Hello!"); /* pretty much anywhere */
  foo( 32 /*, 53*/ ); /* block comments are a simple way to temporarily remove code */
}
          ]]></programlisting>
        </example>
        
        <example>
          <title>Erroneous block comments</title>
          <programlisting><![CDATA[
/* KL ends the comment
 * as soon as the first */
 * is seen, so this is
 * a bad block comment that 
 * results in a syntax error
 */

/* Like C, block comments
 * cannot nest in KL,
   /* so this is also
    * a bad comment that
    * will result in a
    * syntax error
    */
 */
          ]]></programlisting>
        </example>
        
        <para>
          Be careful with block comments; if either of the errors of the type given above occur in your program it can be very difficult to figure out what has gone wrong; the syntax errors you are given will seem to have nothing to do with your program.  For this reason, we recommend that you use line comments, which are described next.
        </para>
      </section>
      
      <section>
        <title>Line Comments</title>
        
        <para>
          A line comment in KL begins with the character sequence <code>//</code> and continues until the end of the line (ASCII character 10).  Unlike block comments, there are no <quote>gotchas</quote> with line comments: they work exactly as expected.  However, they can't be used to comment out sections of code in the middle of a line
        </para>
        
        <example>
          <title>Line comments</title>
          <programlisting language="KL"><![CDATA[
// A simple, one-line line comment

// This is
// a multi-line
// line comment

operator entry() {
  // comment can appear in source code
  report("Hello!"); // pretty much anywhere
  foo( 32 //, 53 ); // can't comment out code in the middle of the line
          ); // but you can continue it on the next line.
}
          ]]></programlisting>
        </example>
      </section>
    </section>
    
    <section>
      <title>Tokens</title>
      
      <para>
        A KL program is <glossterm>parsed</glossterm> as a sequence of tokens.  A token is a sequence of characters that begins with something other than whitespace and is not a comment.  There are four categories of tokens in KL: keywords, identifiers, symbols, and constants.
      </para>
      
      <section>
        <title>Keywords</title>
        
        <para>
          The following is the list of all the keywords in KL:
          
          <simplelist type="vert" columns="3">
            <member><code>alias</code></member>
            <member><code>ArrayProducer</code></member>
            <member><code>break</code></member>
            <member><code>case</code></member>
            <member><code>const</code></member>
            <member><code>continue</code></member>
            <member><code>createArrayCache</code></member>
            <member><code>createArrayGenerator</code></member>
            <member><code>createArrayMap</code></member>
            <member><code>createArrayTransform</code></member>
            <member><code>createConstArray</code></member>
            <member><code>createConstValue</code></member>
            <member><code>createReduce</code></member>
            <member><code>createValueCache</code></member>
            <member><code>createValueGenerator</code></member>
            <member><code>createValueMap</code></member>
            <member><code>createValueTransform</code></member>
            <member><code>default</code></member>
            <member><code>do</code></member>
            <member><code>else</code></member>
            <member><code>false</code></member>
            <member><code>for</code></member>
            <member><code>function</code></member>
            <member><code>if</code></member>
            <member><code>in</code></member>
            <member><code>io</code></member>
            <member><code>operator</code></member>
            <member><code>report</code></member>
            <member><code>return</code></member>
            <member><code>struct</code></member>
            <member><code>switch</code></member>
            <member><code>true</code></member>
            <member><code>use</code></member>
            <member><code>ValueProducer</code></member>
            <member><code>var</code></member>
            <member><code>while</code></member>
          </simplelist>
        </para>
        
        <para>
          Keywords cannot be used as identifiers, ie. cannot be used for variable, parameter, function, constant or type names.
        </para>
      </section>
    
      <section>
        <title>Identifiers</title>
        
        <para>
          Identifiers are a sequence of one or more characters that:
          
          <itemizedlist>
            <listitem><para>begin with any of the characters <code>a</code>...<code>z</code>, <code>A</code>...<code>Z</code> or <code>_</code>; and</para></listitem>
            <listitem><para>are followed by zero or more of the characters <code>a</code>...<code>z</code>, <code>A</code>...<code>Z</code>, <code>0</code>...<code>9</code> or <code>_</code>; and</para></listitem>
          </itemizedlist>
        </para>
        
        <para>
          Identifiers are used in KL for variable names, parameter names, function names, constant names, method names and type names.
          
          <note><para>Note that the built-in base types in KL (eg. <code>Boolean</code>, <code>String</code>, <code>Float32</code>) are not  keywords but rather identifiers.  This is a technical detail which is important in the design of the language grammar but doesn't make much difference in practice; it simply changes certain syntax errors into semantic errors.</para></note>
        </para>
        
        <para>
          Some examples of valid identifiers in KL:
          
          <itemizedlist>
            <listitem><para><code>foo</code></para></listitem>
            <listitem><para><code>someVariable</code></para></listitem>
            <listitem><para><code>MyType</code></para></listitem>
            <listitem><para><code>MyTypeVersion2</code></para></listitem>
            <listitem><para><code>variable_with_underscores</code></para></listitem>
            <listitem><para><code>piBy2</code></para></listitem>
            <listitem><para><code>_</code></para></listitem>
          </itemizedlist>
          
          Some examples of invalid identifiers:
          
          <itemizedlist>
            <listitem><para><code>2by4</code></para></listitem>
            <listitem><para><code>my%Share</code></para></listitem>
            <listitem><para><code>peter.zion@fabric-engine.com</code></para></listitem>
          </itemizedlist>
        </para>
      </section>
      
      <section>
        <title>Symbols</title>
        
        <para>
          A small set of non-alphanumeric, non-underscore characters or short sequences of such characters are the symbols in KL.  They are specifically:

          <simplelist type="vert" columns="8">
            <member><code>=</code></member>
            <member><code>==</code></member>
            <member><code>+</code></member>
            <member><code>+=</code></member>
            <member><code>++</code></member>
            <member><code>-</code></member>
            <member><code>-=</code></member>
            <member><code>--</code></member>
            <member><code>*</code></member>
            <member><code>*=</code></member>
            <member><code>/</code></member>
            <member><code>/=</code></member>
            <member><code>%</code></member>
            <member><code>%=</code></member>
            <member><code>^</code></member>
            <member><code>^=</code></member>
            <member><code>^^</code></member>
            <member><code>&amp;</code></member>
            <member><code>&amp;=</code></member>
            <member><code>&amp;&amp;</code></member>
            <member><code>|</code></member>
            <member><code>|=</code></member>
            <member><code>||</code></member>
            <member><code>[</code></member>
            <member><code>]</code></member>
            <member><code>(</code></member>
            <member><code>)</code></member>
            <member><code>{</code></member>
            <member><code>}</code></member>
            <member><code>;</code></member>
            <member><code>.</code></member>
            <member><code>&lt;</code></member>
            <member><code>&lt;=</code></member>
            <member><code>&lt;&lt;</code></member>
            <member><code>&lt;&lt;=</code></member>
            <member><code>&gt;</code></member>
            <member><code>&gt;=</code></member>
            <member><code>&gt;&gt;</code></member>
            <member><code>&gt;&gt;=</code></member>
            <member><code>~</code></member>
            <member><code>!</code></member>
            <member><code>!=</code></member>
            <member><code>,</code></member>
            <member><code>?</code></member>
            <member><code>;</code></member>
          </simplelist>
        </para>
        
        <para>  
          The KL compiler is <quote>greedy</quote> when looking for symbols: it looks for the longest sequence of characters that are a valid symbol.  This is why <code>==(</code> is treated as the two symbols <code>==</code> and <code>(</code>: there is no symbol starting with <code>==(</code> but <code>==</code> is a symbol.
        </para>
      </section>
      
      <section>
        <title>Constants</title>
        
        <para>
          A constant is a token that is interpreted as a fixed value of a specific type. KL support five types of constants: boolean constants, integer constants, float-point constants, and string constants.  Each of these are explained below.
        </para>
        
        <section>
          <title>Boolean Constants</title>
          
          <para>
            The two keywords <code>true</code> and <code>false</code> are the two boolean constants.  They are each a value of type <code>Boolean</code>.
          </para>
          
          <example>
            <title>Boolean constants</title>
            <programlisting language="KL"><![CDATA[
operator entry() {
  Float32 value = 1.1;
  Index steps = 0;
  Boolean done = false;
  while (!done) {
    value *= value;
    if (value > 2)
      done = true;
    ++steps;
  }
  report("took " + steps + " steps");
}
            ]]></programlisting>
          </example>
          
          <simpara>Output:</simpara>
          
          <informalfigure>
            <screen><![CDATA[
took 3 steps
            ]]></screen>
          </informalfigure>
        </section>
        
        <section xml:id="sec.constants.integer">
          <title>Integer Constants</title>
          
          <para>
            A integer constant can take one of three forms:

            <itemizedlist>
              <listitem><simpara>The single digit <code>0</code></simpara></listitem>
              <listitem><simpara>A decimal constant that starts with a single digit in the range <code>1</code>...<code>9</code> followed by zero or more digits in the range <code>0</code>...<code>9</code></simpara></listitem>
              <listitem><simpara>The two characters <code>0x</code> or <code>0X</code> followed by one or more characters in one of the ranges <code>0</code>...<code>9</code>, <code>a</code>...<code>f</code> and <code>A</code>...<code>F</code></simpara></listitem>
            </itemizedlist>
            
            The type of an integer constant depends on its value:
            
            <itemizedlist>
              <listitem><para>
                If it is less than <inlineequation><mathphrase>2<superscript >31</superscript>-1</mathphrase></inlineequation> then it is of type <code>Integer</code>;
              </para></listitem>
              
              <listitem><para>
                If it is at least <inlineequation><mathphrase>2<superscript >31</superscript></mathphrase></inlineequation> but less than <inlineequation><mathphrase>2<superscript >32</superscript>-1</mathphrase></inlineequation> (on 32-bit platforms) or <inlineequation><mathphrase>2<superscript >64</superscript>-1</mathphrase></inlineequation> (on 64-bit platforms) then it is of type <code>Size</code>;
              </para></listitem>
              
              <listitem><para>
                Otherwise, the integer constant is too large and the compiler will generate a syntax error.
              </para></listitem>
            </itemizedlist>
            
            <note><para>
              All integer constants are positive; a <code>-</code> (minus sign) followed by an integer constant is interpreted as the unary minus operator applied to the integer constant.
            </para></note>
          </para>
            
          <example>
            <title>Integer constants</title>
            <programlisting language="KL"><![CDATA[
operator entry() {
  report(0);
  report(1);
  report(123456789);
  report(0xA9);
  report(0xdeadBEEF);
}
            ]]></programlisting>
          </example>
          
          <simpara>Output:</simpara>
          
          <informalfigure>
            <screen><![CDATA[
0
1
123456789
169
3735928559
            ]]></screen>
          </informalfigure>
        </section>
        
        <section xml:id="sec.constants.floating-point">
          <title>Floating-Point Constants</title>
          
          <para>
            A floating-point constant takes the following form:

            <itemizedlist>
              <listitem><simpara>Either a single <code>0</code> or one digit in the range <code>1</code>...<code>9</code> followed by zero or more digits in the range <code>0</code>...<code>9</code> (the <glossterm>whole part</glossterm>; the same syntax as a decimal integer constant)...</simpara></listitem>
              <listitem><simpara>...optionally followed by a <code>.</code> and zero or more characters in the range <code>0</code>...<code>9</code> (the <glossterm>fractional part</glossterm>)...</simpara></listitem>
              <listitem><simpara>...optionally followed by an <code>e</code> or an <code>E</code>, then optionally by a <code>+</code> or a <code>-</code>, then by one or more characters in the range <code>0</code>...<code>9</code> (the <glossterm>exponent</glossterm>).</simpara></listitem>
            </itemizedlist>
            
            <note><para>C accepts floating-point constants that start with a <code>.</code> but floating-point constants in KL must start with a digit</para></note>
            
            However, for a constant to be floating-point (and not integer) it must have a fractional part, an exponent, or both.
            
            <note><para>
              It is not possible to represent many decimal fractional expressions in IEEE floating point format.  As such, do not be surprised if the output values of such expressions appear to be slightly off, as seen in the example below with the constant <code>8.9e-6</code>.
            </para></note>
          </para>
            
          <para>
            In KL, all floating-point constants are of type <code>Float64</code>, regardless of value.
            
            <note><para>
              All floating-point constants are positive; a <code>-</code> (minus sign) followed by a floating-point constant is interpreted as the unary minus operator applied to the floating-point constant.
            </para></note>
          </para>
            
          <example>
            <title>Floating-point constants</title>
            <programlisting language="KL"><![CDATA[
operator entry() {
  report(0.0);
  report(1.4142);
  report(3.14159265358979);
  report(8.9e-6);
  report(4356.123E42);
}
            ]]></programlisting>
          </example>
          
          <informalfigure>
            <simpara>Output:</simpara>
            <screen><![CDATA[
0
1.4142
3.14159265358979
8.899999999999999e-06
4.356123e+45
            ]]></screen>
          </informalfigure>
        </section>
        
        <section xml:id="sec.constants.string">
          <title>String Constants</title>
          
          <para>
            A string constant takes the following form:

            TBD
          </para>
        </section>
      </section>
    </section>
    
    <section>
      <title>Line Continuations</title>
      
      <para>TBD</para>
    </section>
  </chapter>

  <chapter xml:id="ch.types">
    <title>The KL Type System</title>

    <para>
      Unlike most languages, KL has a dynamic type system that is inherited from the Fabric environment.  In most cases, compound types are registered from the Fabric environment running in a dynamic language (eg. JavaScript or Python); those types are then automatically made available to KL programs running in that environment.  This does not, however, affect the semantics of the language; the KL type system can still be explained purely from the point of view of the language itself.
    </para>

    <para>
      Like most programming languages, KL has support for both a fixed set of base types from which other types are derived as well as different kinds of derived types.
    </para>

    <section>
      <title>Base Types</title>

      <para>
        The base types in KL are the following:

        <variablelist>
          <varlistentry>
            <term><code>Boolean</code></term>
            <listitem><para>a type whose value can be either <code>true</code> or <code>false</code></para></listitem>
          </varlistentry>
    
          <varlistentry>
            <term><code>Byte</code></term>
            <listitem><para>an 8-bit unsigned integer value</para></listitem>
          </varlistentry>
    
          <varlistentry>
            <term><code>Integer</code></term>
            <listitem><para>a 32-bit signed integer value</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Size</code></term>
            <listitem><para>an unsigned integer value which is 32-bit on 32-bit platforms and 64-bit on 64-bit platforms.  <code>Size</code> is usually used to either index into or count the number of elements in an array</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Index</code></term>
            <listitem><para>an alias for <code>Size</code></para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Float32</code></term>
            <listitem><para>a 32-bit IEEE floating point value</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Scalar</code></term>
            <listitem><para>an alias for <code>Float32</code></para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>Float64</code></term>
            <listitem><para>a 64-bit IEEE floating point value</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><code>String</code></term>
            <listitem><para>a sequence of zero or more characters</para></listitem>
          </varlistentry>
        </variablelist>
      </para>
      
      <section>
        <title>The <code>Boolean</code> Type</title>

        <para>
          The value of an expression of <code>Boolean</code> type is either logical true or logical false.  The type has the following properties:

          <itemizedlist>
            <listitem><para>
              The constants <code>true</code> and <code>false</code> are <code>Boolean</code> values with logical values true and false, respectively.
            </para></listitem>

            <listitem><para>
              All other base types cast to Boolean as follows:
              
              <itemizedlist>
                <listitem><para><code>Byte</code>, <code>Integer</code> and <code>Size</code> values cast to true if and only if the value is non-zero</para></listitem>
                <listitem><para><code>Float32</code> and <code>Float64</code> values cast true if and only if the value is not equal to <code>0.0</code> or <code>-0.0</code></para></listitem>
                <listitem><para><code>String</code> values cast to true if and only if their length is greater than zero</para></listitem>
                <listitem><para>arrays and dictionaries cast to true if and only if they are non-empty</para></listitem>
                <listitem><para>by default, structures do not cast to <code>Boolean</code>, but you can implement the cast if desired</para></listitem>
              </itemizedlist>
            </para></listitem>

            <listitem><para>
              For operators:
              
              <itemizedlist>
                <listitem><para>None of the arithmetic operators (binary <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> as well as unary <code>-</code> and <code>+</code>) are valid for <code>Boolean</code> values</para></listitem>
                <listitem><para>Only the <code>==</code> and <code>!=</code> comparison operators are valid for <code>Boolean</code> values</para></listitem>
                <listitem><para>All of the bitwise binary operators (<code>|</code>, <code>&amp;</code>, <code>^</code> and <code>~</code>) are valid for <code>Boolean</code> values and treat the value as if were a single bit</para></listitem>
              </itemizedlist>
            </para></listitem>
          </itemizedlist>
        </para>
        
        <example xml:id="ex.boolean">
          <title>The <code>Boolean</code> type</title>
          <programlisting language="KL"><![CDATA[
operator entry() {
  Boolean a = true;
  report(a);
  Boolean b = a & false;
  report(b);
  report(a != b);
}
          ]]></programlisting>
        </example>

        <simpara>Output:</simpara>
        
        <informalfigure>
          <screen><![CDATA[
true
false
true              
          ]]></screen>
        </informalfigure>
      </section>

      <section>
        <title>Integer Types</title>
        
        <para>
          The <code>Byte</code>, <code>Integer</code> and <code>Size</code> types (collectively known as <glossterm>integer types</glossterm>) represent whole integers.  These types differ only in their bit width and whether they are signed or unsigned, as follows:
          
          <variablelist>
            <varlistentry>
              <term><code>Byte</code></term>
              <listitem><simpara>an 8-bit unsigned integer</simpara></listitem>
            </varlistentry>
            
            <varlistentry>
              <term><code>Integer</code></term>
              <listitem><simpara>a 32-bit signed integer</simpara></listitem>
            </varlistentry>
            
            <varlistentry>
              <term><code>Size</code></term>
              <listitem><simpara>an unsigned integer that is 32-bit on 32-bit systems and 64-bit on 64-bit systems</simpara></listitem>
            </varlistentry>
            
            <varlistentry>
              <term><code>Index</code></term>
              <listitem><simpara>an alias for <code>Size</code></simpara></listitem>
            </varlistentry>
          </variablelist>
        </para>
        
        <para>
          Integer types behave as follows:
          
          <itemizedlist>
            <listitem><simpara>
              Integer constants (eg. <code>43562</code>) are of type <code>Integer</code> if their value is less than <inlineequation><mathphrase>2<superscript >31</superscript>-1</mathphrase></inlineequation>, otherwise they are of type <code>Size</code>.  For more details, see <xref linkend="sec.constants.integer" />.
            </simpara></listitem>

            <listitem><simpara>
              All of the arithmetic, comparison and bitwise operators work as expected for <glossterm>integer types</glossterm>, with the exception of unary <code>-</code> which does not work for values of type <code>Size</code> and <code>Byte</code>.
            </simpara></listitem>
          </itemizedlist>
        </para>
        
        <example xml:id="ex.integers">
          <title>Integer types</title>
          <programlisting language="KL"><![CDATA[
operator entry() {
  Byte b = 64;
  report(b);
  Size s = 45 * Size(b) + 32;
  report(s);
  Integer i = -75 * Integer(s) + 18;
  report(i);
}
          ]]></programlisting>
          <simpara>Output:</simpara>
          <screen><![CDATA[
64
2912
-218382
          ]]></screen>
        </example>
      </section>

      <section>
        <title>Floating-Point Types</title>
        
        <para>
          The <code>Float32</code>, <code>Float64</code> and <code>Scalar</code> types (collectively known as <glossterm>floating-point types</glossterm>) represent <acronym>IEEE</acronym> floating-point numbers.  These types differ only in their bit width, as follows:
          
          <variablelist>
            <varlistentry>
              <term><code>Float32</code></term>
              <listitem><simpara>a 32-bit <acronym>IEEE</acronym> floating-point number</simpara></listitem>
            </varlistentry>
            
            <varlistentry>
              <term><code>Float64</code></term>
              <listitem><simpara>a 64-bit <acronym>IEEE</acronym> floating-point number</simpara></listitem>
            </varlistentry>
            
            <varlistentry>
              <term><code>Scalar</code></term>
              <listitem><para>
                an alias for <code>Float32</code>
                <note><para>The <code>Scalar</code> alias will probably be removed in a future version of KL.  We recommend that you not use it in any new code.</para></note>
              </para></listitem>
            </varlistentry>
          </variablelist>
        </para>
        
        <para>
          Floating-point types behave as follows:
          
          <itemizedlist>
            <listitem><para>
              Floating-point constants have the same syntax as in JavaScript and C, and are of type <code>Float64</code>.  For more details, see <xref linkend="sec.constants.floating-point" />.
            </para></listitem>
            
            <listitem><para>
              All of the arithmetic and comparison operators are valid for floating-point values.  None of the bitwise operators are valid for floating-point values.
            </para></listitem>
          </itemizedlist>
        </para>

        <example xml:id="ex.floats">
          <title>Floating-point types</title>
          <programlisting language="KL"><![CDATA[
operator entry() {
  Float32 x = 3.141;
  report(x);
  Float64 y = 2.718;
  report(y);
  Float32 z = x*x + y*y;
  report(z);
}
          ]]></programlisting>
          <simpara>Output:</simpara>
          <screen><![CDATA[
3.141
2.718
17.2534
          ]]></screen>
        </example>
      </section>

      <section>
        <title>The <code>String</code> Type</title>
        
        <para>
          The <code>String</code> type represents a text string, ie. a sequence of zero or more characters.  A value of type <code>String</code> is referred to as a <glossterm>string value</glossterm>.
        </para>

        <para>          
          The semantics of the <code>String</code> type in KL are important to understand.  Strings have the following key properties:
          
          <itemizedlist>
            <listitem><simpara>A string is a sequence of zero or more characters.</simpara></listitem>
            <listitem><simpara>The length of a string is value of type <code>Size</code>, and the maximum length of a string is the maximum value of type <code>Size</code>.</simpara></listitem>
            <listitem><para>
              String constants can be specified inline in KL source files using single- or double-quotation marks, just as JavaScript.  Examples of string constants:
              
              <itemizedlist>
                <listitem><simpara><code>"Hello, world!"</code></simpara></listitem>
                <listitem><simpara><code>'A string\nwith a newline'</code></simpara></listitem>
                <listitem><simpara><code>"A string containing \"double quotes\""</code></simpara></listitem>
              </itemizedlist>
            </para></listitem>
            <listitem><simpara>Strings are <emphasis>reference-counted</emphasis> and <emphasis>copy-on-write</emphasis>.  This means that if you assign a string value to multiple variables, there is only one copy of the actual string until someone changes one of the strings.</simpara></listitem>
            <listitem><para>
              Strings support the following operations and properties, which are all exactly the same as JavaScript:
              <itemizedlist>
                <listitem><simpara>They have a <property>.length</property> property which returns the number of characters in the string</simpara></listitem>
                <listitem><simpara>The <code>+=</code> assignment operator is used to append another string to a given string</simpara></listitem>
                <listitem><simpara>A new string can be created by concatenating two other strings using the <code>+</code> binary operation</simpara></listitem>
                <listitem><simpara>Strings can be compared using the usual <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> logical operators.</simpara></listitem>
              </itemizedlist>
            </para></listitem>
            <listitem><simpara>Unlike C or C++, strings can contain the null character (ASCII 0).</simpara></listitem>
            <listitem><simpara>Strings have no notion of encoding; they are just sequences of bytes.  String encodings are determined by the application space where the strings are used.  Note that everything in Fabric itself uses the UTF-8 encoding, but Fabric extensions may need to convert strings into other encodings.</simpara></listitem>
            <listitem><simpara>All other types in KL can be converted to strings through a cast; this conversion simply creates a string which is a human-readable version of the value.</simpara></listitem>
          </itemizedlist>
        </para>

        <example>
          <title>String values</title>
          <programlisting language="KL"><![CDATA[
operator entry() {
  String a = "A string";
  report(a);
  report("a has length " + a.length);
  String b = "Another string";
  report(b);
  String c = a + " and " + b;
  report(c);
  b += " now includes " + a;
  report(b);
}
          ]]></programlisting>
          <simpara>Output:</simpara>
          <screen><![CDATA[
A string
a has length 8
Another string
A string and Another string
Another string now includes A string
          ]]></screen>
        </example>
      </section>
    </section>

    <section>
      <title>Derived Types</title>
      
      <para>
        In addition to the base types, KL supports three classes of derived types: structures, arrays and dictionaries.
      </para>
      
      <section>
        <title>Structures</title>
        
        <para>
          A <glossterm>structure</glossterm> is a collection of typed values that are placed together in memory.
        </para>
        
        <para>
          Structures are usually defined outside of KL using Fabric's <glossterm>registered type system</glossterm>, but they can also be declared in KL source code itself using the <code>struct</code> keyword:
          
          <example>
            <title>Structure definition in KL</title>
            <programlisting language="KL"><![CDATA[
struct NewType {
  Float32 firstMember;
  String secondMember;
  Integer thirdMemberVarArray[];
};
            ]]></programlisting>

            <note><simpara>Note the use of the variable-size array as the last member; derived types can nest arbitrarily.</simpara></note>
            <warning><simpara>All structure declarations in KL must be in the global scope; it is not possible to declare a structure within a function scope.</simpara></warning>
          </example>
        </para>
        
        <para>
          More details about structures:
          
          <itemizedlist>
            <listitem><simpara>Access to structure members is through the <code>.</code> operator, as in JavaScript.</simpara></listitem>
            <listitem><simpara>Currently, the structure members are <glossterm>packed</glossterm>, meaning that there is no space in member between the structure members.  In a future version of Fabric it will be possible to explicitly specify structure member alignment and packing.</simpara></listitem>
            <listitem><simpara>It is possible to overload operators and add <glossterm>methods</glossterm> to structures; this will be described below.</simpara></listitem>
          </itemizedlist>
        </para>

        <example>
          <title>Definition and use of a structure</title>
          <programlisting language="KL"><![CDATA[
struct MyNewType {
  Integer i;
  String s;
};

function entry() {
  MyNewType mnt;
  mnt.s = "Hello!";
  mnt.i = 42;
  report(mnt);
}
          ]]></programlisting>
          <simpara>Output:</simpara>
          <screen><![CDATA[
{i:42,s:"Hello!"}
          ]]></screen>
        </example>
      </section>

      <section>
        <title>Arrays</title>
      
        <para>
          An <glossterm>array</glossterm> is a sequence of values of the same type (referred to as the array's <glossterm>element type</glossterm>) that are indexed by integers and placed sequentially in memory.  KL supports three types of arrays: variable-size arrays, fixed-length arrays, and sliced arrays.  The details of each array type are discussed below.
        </para>
      
        <para xml:id="array-properties">
          Regardless of specific type, arrays in KL have several common behaviours:
      
          <itemizedlist>
              <listitem><para>
                Arrays are indexed using the <code>[</code>..<code>]</code> operator, exactly as in JavaScript and C.  The indexing of arrays is 0-based, again just as in JavaScript and C.
              
                <informalexample>
                  <programlisting language="KL"><![CDATA[
Size sizes[];    // Declare a variable-size array
sizes.push(42);  // Push some elements onto the end of the array
sizes.push(21);
sizes.push(3);
report(sizes[1]); // outputs "21"
                  ]]></programlisting>
                </informalexample>
              </para></listitem>
            
              <listitem><simpara>The size of an array is of type <code>Size</code> and the indexing operator takes an index of type <code>Index</code> (which is an alias for <code>Size</code>).</simpara></listitem>
            
              <listitem><para>
                Array declarations can be nested, and can be co-nested with other array types.
                <informalexample>
                  <programlisting language="KL"><![CDATA[
Integer b[][];  // A variable-size array of variable-size arrays of integers
Boolean a[2][]; // An array of 2 variable-size arrays of booleans
String c<>[];   // A sliced array of variable-size 
                  ]]></programlisting>
                </informalexample>
              </para></listitem>

              <listitem><simpara>
                Arrays are <glossterm>passed by reference</glossterm> into functions and operators, ie. they are not copied.  This means that it takes just a long to pass an array with one million elements to a function as it does to pass an array with one element.
              </simpara></listitem>
            
              <listitem><simpara>
                When running within a web browser, indexing into arrays using the indexing operator is bounds-checked; if the index runs off the end of the array, an exception is thrown.  When running Fabric from the command line, arrays are not bounds-checked.
              </simpara></listitem>            
          </itemizedlist>
        </para>
      
        <section>
          <title>Variable-Size Arrays</title>
        
          <para>
            A <glossterm>variable-size array</glossterm> is an array whose size can be changed at runtime.  Variable-size arrays are declared by appending <code>[]</code> to the name of the variable, parameter or structure member where they are declared, eg. <code>String strings[]</code>.
          </para>
          
          <para>
            Variable-size arrays have all the <link linkend="array-properties">properties of arrays</link> as well as the following additional properties:
          
            <itemizedlist>
              <listitem><para>
                The maximum size of a variable-size array is the maximum value of the <code>Size</code> type.  This means that variable-size arrays can be much larger on 64-bit machines than they can on 32-bit machines.
              </para></listitem>
            
              <listitem><para>
                Variable-size arrays are copied when they are assigned.
                <warning><simpara>This means that there is no inexpensive way to assign variable-size arrays; this will probably be fixed in a future version of Fabric.</simpara></warning>
              </para></listitem>
            
              <listitem><para>
                Variable-size arrays support the following methods:
                <itemizedlist>
                  <listitem><simpara>The <code>push(element)</code> method appends an element to the end of the variable-size array</simpara></listitem>
                  <listitem><simpara>The <code>size()</code> method returns the number of elements in the variable-size array</simpara></listitem>
                  <listitem><simpara>The <code>resize(newSize)</code> method resizes the array.  Any new elements at the end are initialized with the default value for the underlying type.</simpara></listitem>
                </itemizedlist>
              </para></listitem>
            </itemizedlist>
          </para>
        
          <example>
            <title>Variable-size arrays</title>
            <programlisting><![CDATA[
operator entry() {
  Integer a[];
  report("The array a has size " + a.size + " and value " + a);
  a.push(42);
  a.push(84);
  report("The array NOW has size " + a.size + " and value " + a);
  a.resize(4);
  report("The array NOW has size " + a.size + " and value " + a);
}
            ]]></programlisting>
            <simpara>Output:</simpara>
            <screen><![CDATA[
The array a has size 0 and value []
The array NOW has size 2 and value [42,84]
The array NOW has size 4 and value [42,84,0,0]
            ]]></screen>
          </example>
        </section>
      
        <section>
          <title>Fixed-Size Arrays</title>
        
          <para>
            A <glossterm>fixed-size array</glossterm> is an array whose size is fixed at runtime.  Fixed-size arrays have much faster performance characteristics than variable-size arrays, therefore should be used in place of variable-sized arrays when the size of an array is known at compile time.  Fixed-size arrays are declared by appending <code>[<replaceable>size</replaceable>]</code> to the name of the variable, parameter or structure member where they are declared, eg. <code>String strings[4]</code>.
          </para>
        
          <para>
            Fixed-size arrays have all the <link linkend="array-properties">properties of arrays</link> as well as the following additional properties:
          
            <itemizedlist>
              <listitem><para>
                The maximum size of a fixed-size array is the maximum value of the <code>Size</code> type.
                <warning><para>Since fixed-size arrays are allocated on the stack (instead of the heap), using very large fixed-size arrays may result in a stack overflow.  It is recommended that fixed-size arrays only be used for arrays that are reasonably small.</para></warning>              
              </para></listitem>
            
              <listitem><para>
                Fixed-size arrays are copied when they are assigned.
                <note><simpara>Unlike variable-size arrays, this behaviour of fixed-size arrays will never change.</simpara></note>
              </para></listitem>
            </itemizedlist>
          </para>
        
          <example>
            <title>Fixed-size arrays</title>
            <programlisting><![CDATA[
function Float32 det(Float32 mat[2][2]) {
  return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

operator entry() {
  Float32 mat[2][2];
  mat[0][0] = 3.5;
  mat[0][1] = -9.2;
  mat[1][0] = -2.1;
  mat[1][1] = 8.6;
  report("The determinant of " + mat + " is " + det(mat));
}
            ]]></programlisting>
            <simpara>Output:</simpara>
            <screen><![CDATA[
The determinant of [[3.5,-9.2],[-2.1,8.6]] is 10.78
            ]]></screen>
          </example>
        </section>

        <section>
          <title>Sliced Arrays</title>
        
          <para>
            A <glossterm>sliced array</glossterm> is an array whose size is fixed when it is created.  Sliced arrays have the unique feature that new sliced arrays can be created that access a sub-range of the elements of an existing sliced array.  Sliced arrays are primarily used for operator parameters bound to sliced data inside Fabric's dependency graph, but can also be used on their own within KL.  Sliced arrays are declared by appending <code>&lt;&gt;</code> to the name of the variable, parameter or structure member where they are declared, eg. <code>String strings&lt;&gt;</code>.
          </para>
          
          <para>
            Sliced arrays have all the <link linkend="array-properties">properties of arrays</link> as well as the following additional properties:
          
            <itemizedlist>
              <listitem><para>
                Within KL, sliced arrays can only be created using one of two syntaxes, shown in the example below:
                
                <informalexample>
                  <programlisting language="KL"><![CDATA[
Size sizes<>(8);                // Create a sliced array of 8 elements of type Size
for (Size i=0; i<8; ++i)
  sizes[i] = i;
  
Size subSizes<>( sizes, 2, 4 ); // A sliced array of elements of type Size that accesses
                                // elements 2 through 5 (inclusive) of the underlying
                                // sliced array
report(subSizes[0]);            // will output '2'
report(subSizes.size);          // will output '4'
                  ]]></programlisting>
                </informalexample>
              </para></listitem>
            
              <listitem><para>
                Sliced arrays as a whole cannot be the target of an assignment.  However, an element of a sliced array (accessed through the <code>[</code>...<code>]</code> index operator) can be assigned to.
              </para></listitem>
            
              <listitem><para>
                Sliced arrays support the following methods:
                <itemizedlist>
                  <listitem><simpara>The <code>size()</code> method returns the number of elements in the sliced array.  If a sliced array refers to a subrange of another sliced array, the value returned is the size of the subrange.</simpara></listitem>
                </itemizedlist>
              </para></listitem>
            </itemizedlist>
          </para>
        
          <example>
            <title>Sliced arrays</title>
            <programlisting><![CDATA[
operator entry() {
  String strings<>(8);
  for (Size i=0; i<8; ++i)
    strings[i] = "string " + (i+1);
  report("strings = " + strings);
  
  String subStrings<>(strings, 2, 4);
  report("subStrings = " + subStrings);
  
  report("Replacing subStrings element...");
  subStrings[3] = "replaced string";
  report("subStrings = " + subStrings);
  report("strings = " + strings);
}
            ]]></programlisting>
            <simpara>Output:</simpara>
            <screen><![CDATA[
strings = ["string 1","string 2","string 3","string 4","string 5","string 6","string 7","string 8"]
subStrings = ["string 3","string 4","string 5","string 6"]
Replacing subStrings element...
subStrings = ["string 3","string 4","string 5","replaced string"]
strings = ["string 1","string 2","string 3","string 4","string 5","replaced string","string 7","string 8"]
            ]]></screen>
          </example>
        </section>
      </section>

      <section>
        <title>Dictionaries</title>
      
        <para>
          KL supports key-value pair dictionaries.  The type of the key of a dictionary can be any of the KL base types (e.g. <code>Boolean</code>, <code>String</code>, or any integer or floating-point type) and the type of the value can be any type.  Dictionaries are declared by appending <code>[<replaceable>KeyType</replaceable>]</code> to the variable, parameter or member name.  For example:
        
          <informalexample><programlisting language="KL"><![CDATA[
String scalarToString[Float32];     // A Float32-to-String dictionary
Boolean integerToBoolean[Integer];  // An Integer-to-Boolean dictionary
          ]]></programlisting></informalexample>
        </para>

        <para>
          Dictionaries in KL have the following properties:
        
          <itemizedlist>
            <listitem><para>
              Dictionaries are copied on assignment.  However, they are always passed by reference to functions.
              <note><para>The copy-on-assignment property of dictionaries is likely to change in a future version of KL.</para></note>
            </para></listitem>
          
            <listitem><para>
              Dictionaries can be nested, and can be co-nested with array types.  For example:
            
              <informalexample><programlisting language="KL"><![CDATA[
Integer b[String][2]; // An String-to-Fixed-Length-Integer-Array dictionary
Boolean a[][Integer]; // A variable array of Integer-to-Boolean dictionaries
              ]]></programlisting></informalexample>
            </para></listitem>
          
            <listitem><para>There is no limit to the size of dictionaries other than available memory</para></listitem>
            <listitem><para>
              Dictionaries support indexing using the <code>[<replaceable>key</replaceable>]</code> indexing operator to both return the element at the give key or assign to the element at the given key.  When retrieving a value from a dictionary, if there is no value for the given key then an exception is thrown.</para></listitem>
            <listitem><para>Dictionaries support the <code>has(<replaceable>key</replaceable>)</code> method that returns a <code>Boolean</code> value indicating whether there is a value in the dictionary for the given key.</para></listitem>
            <listitem><para>Dictionaries support the <code>delete(<replaceable>key</replaceable>)</code> method that deletes the value for the given key.  If there is no value for the given key, nothing happens.</para></listitem>

            <listitem><para>
              Dictionaries can be iterated over using JavaScript-like <code>in</code> iteration:
            
              <informalexample><programlisting language="KL"><![CDATA[
String dict[String];
for (k in dict)
  report("dict[" + k + "] = " + dict[k]);
              ]]></programlisting></informalexample>
            
              For improved performance, both the key and value can be made available through <code>in</code> iteration.  The value can be assigned to if and only if the dictionary can be assigned to.  For example:
            
              <informalexample><programlisting language="KL"><![CDATA[
String dict[String];
for (k, v in dict)
  report("dict[" + k + "] = " + v);
              ]]></programlisting></informalexample>
            </para></listitem>

            <listitem><para>
              Insertion order (not sort order!) is the iteration order for dictionaries, just as for JavaScript objects.

              <informalexample><programlisting language="KL"><![CDATA[
operator entry() {
  String numbers[Integer];
  numbers[3] = "three";
  numbers[2] = "two";
  report(numbers); // outputs '{3:"three",2:"two"}'
  numbers[1] = "one";
  report(numbers); // outputs '{3:"three",2:"two",1:"one"}'
}
              ]]></programlisting></informalexample>
            </para></listitem>
          </itemizedlist>
        </para>

        <example>
          <title>Dictionaries</title>
          <programlisting><![CDATA[
operator entry() {
  Float32 a[String];
  a['pi'] = 3.14;
  a['e'] = 2.71;
  report("a is:");
  for ( k, v in a ) {
    report("a['" + k + "'] = " + v);
  }
  a.delete('pi');
  report("a is now:");
  for ( k, v in a ) {
    report("a['" + k + "'] = " + v);
  }
}
          ]]></programlisting>
          <simpara>Output:</simpara>
          <screen><![CDATA[
a is:
a['pi'] = 3.14
a['e'] = 2.71
a is now:
a['e'] = 2.71
        ]]></screen>
        </example>
      </section>
    </section>

    <section>
      <title>Type Aliases</title>
      
      <para>
        The <code>alias</code> statement can be used to alias a type to make code more readable.  Its syntax is the same as a variable declaration:
        
        <programlisting language="KL"><![CDATA[
alias Integer Int32;        // Int32 is now an alias for Integer
alias Float32 float;        // float is now an alias for Float32
alias Float32 Mat22[2][2];  // Mat22 is now an alias for Float32[2][2], ie. a size-2-array-of-size-2-arrays-of-Float32
        ]]></programlisting>
        
        <code>alias</code> statements must appear within the global scope of a KL program.
      </para>
      
      <example>
        <title>Type aliases</title>
        <programlisting><![CDATA[
alias Float32 Mat22[2][2];

operator entry() {
  Mat22 mat22;
  report(mat22);
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
[[0,0],[0,0]]
      ]]></screen>
      </example>
    </section>

    <section>
      <title>The <code>Data</code> Type and the <code>data</code> and <code>dataSize</code> Methods</title>

      <para>
        When interfacing with external libraries such as OpenGL, it is sometimes necessary to get direct access to the data underlying a value.  An example is a library call that takes a pointer to data.  KL itself has no notion of pointers; instead, KL has the concept of the <code>Data</code> type whose value is a pointer to data which can be passed to an external library call.
      </para>

      <para>
        Most values in KL have a built-in method called <code>data</code> that returns a value of type <code>Data</code>, and a built-in method called <code>dataSize</code> that returns a value of type <code>Size</code>.  The value returned by the <code>data</code> method is a pointer to the data underlying the value, and the value returned by the <code>dataSize</code> method is the number of bytes the value occupies in memory.  The only values which do not support the <code>data</code> and <code>dataSize</code> methods are dictionaries as well as other derived types that do not lay out their elements or members contiguously in memory.
        
        <programlisting language="KL"><![CDATA[
Integer integers[];
report(integers.data);  // OK: integers are contiguous in memory
String strings[];
report(strings.data);   // ERROR: string data is not contiguous in memory
        ]]></programlisting>
      </para>

      <para>
        Unlike pointers in C, the values returned by <code>data</code> methods cannot be inspected or used in any expressions; the only thing which can be done is a cast to <code>Boolean</code>, which will be <code>true</code> if and only if the <code>Data</code> value points to a value whose size is greater than zero.  However, these <code>Data</code> values can be passed directly to external library functions provided by Fabric itself or Fabric extensions, where they are used as pointers to data in memory.
      </para>

      <note><para>
        For values of type <code>String</code>, the value returned by <code>dataSize</code> includes a null terminator which is automatically appended to the string by Fabric; this is so that the string data can be directly used in C library calls as a regular C string.  If you want to pass the number of characters in the string, pass <code>string.length</code> instead.
      </para></note>

      <example>
        <title><code>Data</code> values and the <code>data</code> and <code>dataSize</code> methods</title>
        <programlisting language="KL"><![CDATA[
operator entry() {
  String s;
  report("s = '" + s + "'");
  report("s.data = " + s.data);
  report("Boolean(s.data) = " + Boolean(s.data));
  report("s.dataSize = " + s.dataSize);
  s = "Hello";
  report("s = '" + s + "'");
  report("s.data = " + s.data);
  report("Boolean(s.data) = " + Boolean(s.data));
  report("s.dataSize = " + s.dataSize);
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
s = ''
s.data = <Opaque>
Boolean(s.data) = false
s.dataSize = 1
s = 'Hello'
s.data = <Opaque>
Boolean(s.data) = true
s.dataSize = 6
      ]]></screen>
      </example>
    </section>
  </chapter>
  
  <chapter xml:id="ch.functions">
    <title>KL Functions</title>

    <section>
      <title>Function Declarations</title>

      <para>
        Function declarations in KL are much the same as the <quote>traditional</quote> function declaration syntax in JavaScript, with the following key differences:

        <itemizedlist>
          <listitem><para>The return type and the type of each function parameter must be explicitly declared.  If a function does not return a value, the return type must be omitted.</para></listitem>
          <listitem><para>The parameter declarations may additionally declare the parameter as input (read-only; the default) by preceding the type by <code>in</code> or input-output (read-write) by preceding the value by <code>io</code>.</para></listitem>
        </itemizedlist>
      </para>

      <example>
        <title>Function returning a value and using only input parameters</title>
        <programlisting language="KL"><![CDATA[
function Float32 add(Float32 lhs, Float32 rhs) {
  return lhs + rhs;
}
        ]]></programlisting>
      </example>

      <example>
        <title>Function not returning a value and using both input and input-output parameters</title>
        <programlisting language="KL"><![CDATA[
function add(in Float32 lhs, in Float32 rhs, io Float32 result) {
  result = lhs + rhs;
}
        ]]></programlisting>
      </example>
    </section>
    
    <section>
      <title>Function Calls</title>
      
      <para>
        Function calls are made using the same syntax as JavaScript, namely by appending a comma-delimited list of arguments, surrounded by parentheses, to the function name.
      </para>
      
      <example>
        <title>Function call</title>
        <programlisting language="KL"><![CDATA[
function Integer add(Integer lhs, Integer rhs) {
  return lhs + rhs;
}

operator entry() {
  report("2 plus 2 is " + add(2, 2));
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
2 plus 2 is 4
        ]]></screen>
      </example>
    </section>
    
    <section>
      <title>Function Prototypes</title>
      
      <para>
        A <glossterm>function prototype</glossterm> in KL is a function declaration that is missing a body.  Providing a function prototype allows the function to be called before it is defined.  This is useful under two circumstances:
        
        <itemizedlist>
          <listitem><para>
            When two or more functions call each other.  Such functions are sometimes referred to as <glossterm>co-recursive</glossterm>.
            
            <example>
              <title>Co-recursion using a prototype</title>
              <programlisting language="KL"><![CDATA[
// Function prototype for 'two', so that 'one' can call it before it is defined
function two(Integer n);

// The function 'one' calls 'two' even though it is not yet defined
function one(Integer n) {
  report("one");
  if (n > 0)
    two(n - 1);
}

// The definition of the function 'two' comes after its prototype
function two(Integer n) {
  report("two");
  if (n > 0)
    one(n - 1);
}

operator entry() {
  one(4);
}
              ]]></programlisting>
              <simpara>Output:</simpara>
              <screen><![CDATA[
one
two
one
two
one
              ]]></screen>
            </example>
          </para></listitem>
          
          <listitem><para>
            When a function definition is provided by a Fabric extension.  The name of the symbol of the function in the Fabric extension is provided by appending <code>= "<replaceable>symbol name</replaceable>"</code> or <code>= '<replaceable>symbol name</replaceable>'</code> to the function prototype.
            
            <example>
              <title>External function</title>
              <programlisting language="KL"><![CDATA[
// The prototype 'libc_perror' is linked to an external function 'perror'
function libc_perror(Data cString) = 'perror';

// The KL function 'perror' is what KL functions actually call
function perror(String string) {
  libc_perror(string.data);
}

operator entry() {
  perror("something that caused an error");
}
              ]]></programlisting>
            </example>
          </para></listitem>
        </itemizedlist>
      </para>
    </section>
    
    <section>
      <title>Built-in Functions</title>
      
      <para>TBD</para>
    </section>

    <section>
      <title>Function Polymorphism</title>
      
      <para>
        KL support <glossterm>compile-type function polymorphism</glossterm>.  This means that you can have multiple functions with the same name so long as they have a different number of parameters or those parameters differ by type and/or their input versus input-output qualification.

        <note><para>It is an error to have two functions with the same name that take exactly the same parameter types but return different types</para></note>
      </para>

      <para>
        When a function call is made in KL source, if there are multiple functions with the same name then the KL compiler uses a best-match system to determine which function to call.  Exact parameter type matches are always prioritized over type casts.  If the compiler is unable to choose a unique best match then an error will be reported showing the ambiguity.
      </para>

      <example>
        <title>Function polymorphism</title>
        <programlisting language="KL"><![CDATA[
function display(Integer a) {
  report("integer value is " + a);
}

function display(String s) {
  report("string value is '" + s + "'");
}

operator entry() {
  Integer integer = 42;
  display(integer);
  
  String string = "hello";
  display(string);
  
  Byte byte = 64;
  display(byte);
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
integer value is 42
string value is 'hello'
integer value is 64
        ]]></screen>
      </example>
    </section>

    <section xml:id="operators">
      <title>Operators</title>
      
      <para>
        The <code>operator</code> keyword in KL is used to mark functions that are to be used as entry points into KL from the Fabric dependency graph.  Operators are declared in the same way as functions except that they must not return a value.  Fabric does special type-checking to ensure that operators are bound properly to nodes in a Fabric dependency graph.
      </para>

      <example>
        <title>Operator definition</title>
        <programlisting language="KL"><![CDATA[
operator addElements(io Float32 lhs, io Float32 rhs, io Float32 result) {
  result = lhs + rhs;
}
        ]]></programlisting>
      </example>
    </section>

    <section>
      <title>Constructors</title>
      
      <para>
        A <glossterm>constructor</glossterm> for a user-defined type is a function that initializes a value with the given the type from other values.
      </para>
      
      <section>
        <title>Constructor Declarations</title>
        
        <para>
          A constructor is declared as a function whose name is the name of the user-defined type.  The function can take any number of parameters, all of which must be input parameters; constructors cannot take input-output parameters.  Constructors cannot return values.
        </para>
        
        <para>
          Within the body of a constructor definition, the value being initialized is referred to with the <code>this</code> keyword; its members are accessed using the <code>.</code> operator.  In this context, <code>this</code> is always read-write, ie. its members can be modified.
        </para>

        <example>
          <title>Constructor declarations</title>
          <programlisting language="KL"><![CDATA[
struct Complex32 {
  Float32 re;
  Float32 im;
};

// The empty constructor; 
function Complex32() {
  this.re = this.im = 0.0;
}

// Construct a Complex from a Float32
function Complex32(Float32 x) {
  this.re = x;
  this.im = 0.0;
}

// Construct a Complex from two Float32s
function Complex32(Float32 x, Float32 y) {
  this.re = x;
  this.im = y;
}

operator entry() {
  report(Complex32());
  report(Complex32(3.141));
  report(Complex32(3.141, 2.718));
}
          ]]></programlisting>
        </example>
        
        <simpara>Output:</simpara>
        
        <informalfigure>
          <screen><![CDATA[
{re:0,im:0}
{re:3.141,im:0}
{re:3.141,im:2.718}
          ]]></screen>
        </informalfigure>
      </section>
      
      <section>
        <title>Constructor Invocation</title>
        
        <para>
          Constructors are invoked in one of several ways:
          
          <itemizedlist>
            <listitem><para>
              If a variable is declared without any initialization, the <glossterm>empty constructor</glossterm> (ie. the constructor that takes no parameters) is invoked to initialize the variable.  This is referred to as <glossterm>naked initialization</glossterm>.
              
              <example>
                <title>Constructor invocation using naked initialization</title>
                <programlisting language="KL"><![CDATA[
struct MyType {
  Integer n;
  Float32 x;
};

// The empty constructor
function MyType() {
  this.n = 42;
  this.x = 3.141;
}

operator entry() {
  MyType myType; // invokes the empty constructor
  report(myType);
}
                ]]></programlisting>
                <simpara>Output:</simpara>
                <screen><![CDATA[
{n:42,x:3.141}
                ]]></screen>
              </example>
            </para></listitem>
            
            <listitem><para>
              If a variable is assigned to as part of its declaration, a single-parameter constructor is invoked.  This is referred to as <glossterm>assignment initialization</glossterm>.  If there isn't an exact match for the type of the value assigned, best-match polymorphism rules are used to choose the constructor to invoke.
              
              <example>
                <title>Constructor invocation using assignment initialization</title>
                <programlisting language="KL"><![CDATA[
struct MyType {
  String string;
};

// Construct from a string
function MyType(String string) {
  this.string = "The string was '" + string + "'";
}

// Construct from a scalar
function MyType(Float64 float64) {
  this.string = "The float64 was " + float64;
}

operator entry() {
  // Construct MyType from String value
  MyType myTypeFromString = "foo";
  report(myTypeFromString);
  
  // Construct MyType from Float64 value
  MyType myTypeFromFloat64 = 2.718;
  report(myTypeFromFloat64);
  
  // There is no constructor that takes a Boolean but
  // there is a cast from Boolean to String
  MyType myTypeFromBoolean = true;
  report(myTypeFromBoolean);
}
                ]]></programlisting>
                <simpara>Output:</simpara>
                <screen><![CDATA[
{string:"The string was 'foo'"}
{string:"The float64 was 2.718"}
{string:"The string was 'true'"}
                ]]></screen>
              </example>
            </para></listitem>
            
            <listitem><para>
              If a variable is <quote>called</quote> (ie. using function call syntax) as part of its declaration, the constructor taking the given arguments is invoked.  This is referred to as <glossterm>invocation initialization</glossterm>.  If there isn't an exact match for the arguments passed to the call, best-match polymorphism rules are used to choose the constructor to invoke.
              
              <example>
                <title>Constructor invocation using invocation initialization</title>
                <programlisting language="KL"><![CDATA[
struct Vec2 {
  Float64 x;
  Float64 y;
};

// Construct from two scalars
function Vec2(Float64 x, Float64 y) {
  this.x = x;
  this.y = y;
}

operator entry() {
  Vec2 vec2FromFloat64s(3.141, 2.718);
  report(vec2FromFloat64s);
  Vec2 vec2FromIntegers(42, -7);  // Uses best-match polymorphism to convert Integer to Float64
  report(vec2FromIntegers);
}
                ]]></programlisting>
                <simpara>Output:</simpara>
                <screen><![CDATA[
{x:3.141,y:2.718}
{x:42,y:-7}
                ]]></screen>
              </example>
            </para></listitem>

            
            <listitem><para>
              If a function call is performed where the name of the function is the name of the type, the constructor taking the given arguments is invoked to create a temporary value of the named type.  If there isn't an exact match for the arguments passed to the call, best-match polymorphism rules are used to choose the constructor to invoke.
              
              <note><para>Note that KL does not distinguish between construction and casting.  Casting a value to a different type is the same as constructing a temporary value of the given type and initializing it, using the appropriate constructor, from the given value.</para></note>
              
              <example>
                <title>Constructor invocation using temporary value</title>
                <programlisting language="KL"><![CDATA[
struct Vec2 {
  Float64 x;
  Float64 y;
};

// Construct from two scalars
function Vec2(Float64 x, Float64 y) {
  this.x = x;
  this.y = y;
}

operator entry() {
  report(Vec2(3.141, 2.718));
  report(Vec2(42, -7));  // Uses best-match polymorphism to convert Integer to Float64
}
                ]]></programlisting>
                <simpara>Output:</simpara>
                <screen><![CDATA[
{x:3.141,y:2.718}
{x:42,y:-7}
                ]]></screen>
              </example>
            </para></listitem>
          </itemizedlist>
        </para>
      </section>
    </section>
    
    <section>
      <title>Destructors</title>
      
      <para>
        A destructor is a function that is called when a variable goes out of scope and its resources are freed.  Destructors are declared by prepending <code>~</code> in front of the name of the type and using it as a function.  Destructors cannot take any parameters or return values.  The destructor is called before the value is freed so that its members are still accessible.  In the body of the destructor the value is referred to using the <code>this</code> keyword; the value is input-ouput, ie. it can be modified in the destructor.
      </para>
      
      <example>
        <title>Destructor</title>
        <programlisting language="KL"><![CDATA[
struct MyType {
  String s;
};

// Empty constructor
function MyType() {
  this.s = "foo";
  report "Creating MyType: this.s = " + this.s;
}

// Destructor
function ~MyType() {
  report "Destroying MyType: this.s = " + this.s;
}

operator entry() {
  MyType myType;
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
Creating MyType: this.s = foo
Destroying MyType: this.s = foo
        ]]></screen>
      </example>
    </section>

    <section>
      <title>Methods</title>

      <para>
        If <code><replaceable>Type</replaceable></code> is a structure or alias, then a <glossterm>method</glossterm> can be added to the type using the following syntax:
        
        <programlisting language="KL">
// A method that returns a value
function <replaceable>ReturnType</replaceable> <replaceable>Type</replaceable>.<replaceable>methodName</replaceable>(<replaceable>parameter list</replaceable>) {
  <replaceable>method body</replaceable>
}

// A method that does not return a value
function <replaceable>Type</replaceable>.<replaceable>methodName</replaceable>(<replaceable>parameter list</replaceable>) {
  <replaceable>method body</replaceable>
}
        </programlisting>
        
        Within the method body, <code>this</code> refers to the value on which the method is called.  <code>this</code> is read-only if the method returns a value and is read-write if the method does not return a value.
        
        <note><para>A future version of Fabric will allow the read-only versus read-write status of <code>this</code> to be explicitly specified.</para></note>
      </para>
      
      <para>
        If <code><replaceable>value</replaceable></code> is a value of type <code><replaceable>Type</replaceable></code> then the method <code><replaceable>methodName</replaceable></code> can be invoked on <code><replaceable>value</replaceable></code> using the expression <code><replaceable>value</replaceable>.<replaceable>methodName</replaceable>(<replaceable>argument list</replaceable>)</code>.  If a method takes no parameters, then it is optional to use parentheses when calling it.
      </para>
      
      <para>
        Just as their can be multiple functions with the same name, a given type can have multiple methods with the same name.  When deciding which method to invoke, the usual best-match rules apply.
      </para>

      <example>
        <title>Method definition and invocation</title>
        <programlisting language="KL"><![CDATA[
struct Type {
  Integer a;
  Float32 b;
};

// Add method desc to Type
function String Type.desc() {
  return "a:" + this.a + "; b:" + this.b;
}

operator entry() {
  Type t;
  t.a = 1;
  t.b = 3.14;
  // Both report 'a:1; b:3.14'
  report t.desc();
  report t.desc;
}
        ]]></programlisting>
        <simpara>Output:</simpara>
        <screen><![CDATA[
a:1; b:3.14
a:1; b:3.14
        ]]></screen>
      </example>
    </section>

    <section>
      <title>Overloaded Operators</title>
      
      <para>
        KL allows overloading of binary and assignment operators for custom types (ie. specified through <code>struct</code>).
      </para>
        
      <section>
        <title>Binary Operator Overloads</title>
      
        <para>
          Binary operators can be overloaded using the following syntax:
      
          <example>
            <title>Binary operator overload</title>
            <programlisting language="KL"><![CDATA[
struct Type {
  Integer a;
  Float32 b;
};

function Type +(Type lhs, Type rhs) {
  Type result;
  result.a = lhs.a + rhs.a;
  result.b = lhs.b + rhs.b;
  return result;
}

operator entry() {
  Type t1; t1.a = 42; t1.b = 3.14; report t1;
  Type t2; t2.a = 7; t2.b = 2.72; report t2;
  Type t3 = t1 + t2; report t3;
}
            ]]></programlisting>
            <simpara>Output:</simpara>
            <screen><![CDATA[
{a:42,b:3.14}
{a:7,b:2.72}
{a:49,b:5.86}
            ]]></screen>
          </example>

          Any of the binary arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>), bitwise (<code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code> and <code>&gt;&gt;</code>) and comparison (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>) operators can be overloaded.
        </para>
      
        <para>
          Binary operator overloads are subject to the following restrictions:
        
          <itemizedlist>
            <listitem><simpara>They must take exactly two parameters.  The two parameters may be of any type and the two types may be different but they must both be input-only parameters.</simpara></listitem>
            <listitem><simpara>They must return a value.  However, the return type can be any type.</simpara></listitem>
          </itemizedlist>
        </para>
      </section>
    
      <section>
        <title>Compound Assignment Overloads</title>
      
        <para>
          KL provides a default plain assignment for custom types which simply assigns each of the members.  It also provides a default <glossterm>compound assignment</glossterm> operator (ie. <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>|=</code>, <code>&amp;=</code>, <code>^=</code>, <code>&lt;&lt;=</code> and <code>&gt;&gt;=</code>) by composing the associated binary operator, if available, with an assignment.
        </para>
      
        <para>
          However, it is also possible to provide an overload for any of the compound assignment operators using the following syntax:

          <example>
            <title>Compound assignment overload</title>
            <programlisting language="KL"><![CDATA[
struct Type {
  Integer a;
  Float32 b;
};

function Type.+=(Type that) {
  this.a += that.a;
  this.b += that.b;
}

operator entry() {
  Type t1; t1.a = 42; t1.b = 3.14; report "t1 is " + t1;
  Type t2; t2.a = 7; t2.b = 2.72; report "t2 is " + t2;
  t1 += t2; report "t1 is now " + t1;
}
            ]]></programlisting>
            <simpara>Output:</simpara>
            <screen><![CDATA[
t1 is {a:42,b:3.14}
t2 is {a:7,b:2.72}
t1 is now {a:49,b:5.86}
            ]]></screen>
          </example>
        </para>
      
        <para>
          Compound assignment overloads are subject to the following restrictions:
        
          <itemizedlist>
            <listitem><simpara>They must take exactly one parameter.  The parameter may be of any type but it must be an input-only parameter.</simpara></listitem>
            <listitem><simpara>They must not return a value.</simpara></listitem>
          </itemizedlist>
        </para>
      </section>
    </section>
  </chapter>
</book>
